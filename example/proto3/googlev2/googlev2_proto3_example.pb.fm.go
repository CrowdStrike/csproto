// GENERATED CODE - DO NOT EDIT
// This file was generated by protoc-gen-fastmarshal

package googlev2

import (
	"fmt"
	"sync/atomic"
	"github.com/CrowdStrike/csproto"
	"google.golang.org/protobuf/types/known/structpb"
	"google.golang.org/protobuf/types/known/timestamppb"
)

//------------------------------------------------------------------------------
// Custom Protobuf size/marshal/unmarshal code for TestEvent

// Size calculates and returns the size, in bytes, required to hold the contents of m using the Protobuf
// binary encoding.
func (m *TestEvent) Size() int {
	// nil message is always 0 bytes
	if m == nil {
		return 0
	}
	// return cached size, if present
	if csz := int(atomic.LoadInt32(&m.sizeCache)); csz > 0 {
		return csz
	}
	// calculate and cache
	var sz, l int
	_ = l // avoid unused variable

	// Name (string,optional)
	if l = len(m.Name); l > 0 {
		sz += csproto.SizeOfTagKey(1) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// Info (string,optional)
	if l = len(m.Info); l > 0 {
		sz += csproto.SizeOfTagKey(2) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// IsAwesome (bool,optional)
	if m.IsAwesome {
		sz += csproto.SizeOfTagKey(3) + 1
	}
	// Labels (string,repeated)
	for _, sv := range m.Labels {
		l = len(sv)
		sz += csproto.SizeOfTagKey(4) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// Embedded (message,optional)
	if m.Embedded != nil {
		l = csproto.Size(m.Embedded)
		sz += csproto.SizeOfTagKey(5) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// Nested (message,optional)
	if m.Nested != nil {
		l = csproto.Size(m.Nested)
		sz += csproto.SizeOfTagKey(9) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// Ts (message,optional)
	if m.Ts != nil {
		l = csproto.Size(m.Ts)
		sz += csproto.SizeOfTagKey(10) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// NullVal (enum,optional)
	if m.NullVal != 0 {
		sz += csproto.SizeOfTagKey(11) + csproto.SizeOfVarint(uint64(m.NullVal))
	}
	// Path (oneof)
	if m.Path != nil {
		switch typedVal := m.Path.(type) {
		case *TestEvent_Jedi: // jedi (6,bool)
			sz += csproto.SizeOfTagKey(6) + 1
		case *TestEvent_Sith: // sith (7,bool)
			sz += csproto.SizeOfTagKey(7) + 1
		case *TestEvent_Other: // other (8,string)
			l = len(typedVal.Other)
			sz += csproto.SizeOfTagKey(8) + csproto.SizeOfVarint(uint64(l)) + l
		default:
			_ = typedVal // ensure no unused variable
		}
	}

	// Oneofs (oneof)
	if m.Oneofs != nil {
		switch typedVal := m.Oneofs.(type) {
		case *TestEvent_Timestamps: // timestamps (12,message)
			if l = csproto.Size(typedVal.Timestamps); l > 0 {
				sz += csproto.SizeOfTagKey(12) + csproto.SizeOfVarint(uint64(l)) + l
			}
		case *TestEvent_Structs: // structs (13,message)
			if l = csproto.Size(typedVal.Structs); l > 0 {
				sz += csproto.SizeOfTagKey(13) + csproto.SizeOfVarint(uint64(l)) + l
			}
		default:
			_ = typedVal // ensure no unused variable
		}
	}

	// cache the size so it can be re-used in Marshal()/MarshalTo()
	atomic.StoreInt32(&m.sizeCache, int32(sz))
	return sz
}

// Marshal converts the contents of m to the Protobuf binary encoding and returns the result or an error.
func (m *TestEvent) Marshal() ([]byte, error) {
	siz := m.Size()
	buf := make([]byte, siz)
	err := m.MarshalTo(buf)
	return buf, err
}

// MarshalTo converts the contents of m to the Protobuf binary encoding and writes the result to dest.
func (m *TestEvent) MarshalTo(dest []byte) error {
	var (
		enc    = csproto.NewEncoder(dest)
		buf    []byte
		err    error
		extVal interface{}
	)
	// ensure no unused variables
	_ = enc
	_ = buf
	_ = err
	_ = extVal

	// Name (1,string,optional)
	if len(m.Name) > 0 {
		enc.EncodeString(1, m.Name)
	}
	// Info (2,string,optional)
	if len(m.Info) > 0 {
		enc.EncodeString(2, m.Info)
	}
	// IsAwesome (3,bool,optional)
	if m.IsAwesome {
		enc.EncodeBool(3, m.IsAwesome)
	}
	// Labels (4,string,repeated)
	for _, val := range m.Labels {
		enc.EncodeString(4, val)
	}
	// Embedded (5,message,optional)
	if m.Embedded != nil {
		if err = enc.EncodeNested(5, m.Embedded); err != nil {
			return fmt.Errorf("unable to encode message data for field 'embedded' (tag=5): %w", err)
		}
	}
	// Nested (9,message,optional)
	if m.Nested != nil {
		if err = enc.EncodeNested(9, m.Nested); err != nil {
			return fmt.Errorf("unable to encode message data for field 'nested' (tag=9): %w", err)
		}
	}
	// Ts (10,message,optional)
	if m.Ts != nil {
		if err = enc.EncodeNested(10, m.Ts); err != nil {
			return fmt.Errorf("unable to encode message data for field 'ts' (tag=10): %w", err)
		}
	}
	// NullVal (11,enum,optional)
	if m.NullVal != 0 {
		enc.EncodeInt32(11, int32(m.NullVal))
	}
	// Path (oneof)
	if m.Path != nil {
		switch typedVal := m.Path.(type) {
		case *TestEvent_Jedi: // jedi (6,bool)
			enc.EncodeBool(6, typedVal.Jedi)
		case *TestEvent_Sith: // sith (7,bool)
			enc.EncodeBool(7, typedVal.Sith)
		case *TestEvent_Other: // other (8,string)
			enc.EncodeString(8, typedVal.Other)
		default:
			_ = typedVal // ensure no unused variable
		}
	}
	// Oneofs (oneof)
	if m.Oneofs != nil {
		switch typedVal := m.Oneofs.(type) {
		case *TestEvent_Timestamps: // timestamps (12,message)
			enc.EncodeNested(12, typedVal.Timestamps)
		case *TestEvent_Structs: // structs (13,message)
			enc.EncodeNested(13, typedVal.Structs)
		default:
			_ = typedVal // ensure no unused variable
		}
	}
	return nil
}

// Unmarshal decodes a binary encoded Protobuf message from p and populates m with the result.
func (m *TestEvent) Unmarshal(p []byte) error {
	m.Reset()
	if len(p) == 0 {
		return nil
	}
	dec := csproto.NewDecoder(p)
	for dec.More() {
		tag, wt, err := dec.DecodeTag()
		if err != nil {
			return err
		}
		switch tag {
		case 1: // Name (string,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'name' (tag=1), expected 2 (length-delimited)", wt)
			}
			if s, err := dec.DecodeString(); err != nil {
				return fmt.Errorf("unable to decode string value for field 'name' (tag=1): %w", err)
			} else {
				m.Name = s
			}

		case 2: // Info (string,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'info' (tag=2), expected 2 (length-delimited)", wt)
			}
			if s, err := dec.DecodeString(); err != nil {
				return fmt.Errorf("unable to decode string value for field 'info' (tag=2): %w", err)
			} else {
				m.Info = s
			}

		case 3: // IsAwesome (bool,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'isAwesome' (tag=3), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeBool(); err != nil {
				return fmt.Errorf("unable to decode boolean value for field 'isAwesome' (tag=3): %w", err)
			} else {
				m.IsAwesome = v
			}
		case 4: // Labels (string,repeated)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'labels' (tag=4), expected 2 (length-delimited)", wt)
			}
			if s, err := dec.DecodeString(); err != nil {
				return fmt.Errorf("unable to decode string value for field 'labels' (tag=4): %w", err)
			} else {
				m.Labels = append(m.Labels, s)
			}

		case 5: // Embedded (message,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'embedded' (tag=5), expected 2 (length-delimited)", wt)
			}
			var mm EmbeddedEvent
			if err = dec.DecodeNested(&mm); err != nil {
				return fmt.Errorf("unable to decode message value for field 'embedded' (tag=5): %w", err)
			}
			m.Embedded = &mm

		case 9: // Nested (message,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'nested' (tag=9), expected 2 (length-delimited)", wt)
			}
			var mm TestEvent_NestedMsg
			if err = dec.DecodeNested(&mm); err != nil {
				return fmt.Errorf("unable to decode message value for field 'nested' (tag=9): %w", err)
			}
			m.Nested = &mm
		case 10: // Ts (message,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'ts' (tag=10), expected 2 (length-delimited)", wt)
			}
			var mm timestamppb.Timestamp
			if err = dec.DecodeNested(&mm); err != nil {
				return fmt.Errorf("unable to decode message value for field 'ts' (tag=10): %w", err)
			}
			m.Ts = &mm
		case 11: // NullVal (enum,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'nullVal' (tag=11), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt32(); err != nil {
				return fmt.Errorf("unable to decode int32 enum value for field 'nullVal' (tag=11): %w", err)
			} else {
				m.NullVal = structpb.NullValue(v)
			}

		case 6: // path.jedi (oneof,bool)
			var ov TestEvent_Jedi
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'jedi' (tag=6), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeBool(); err != nil {
				return fmt.Errorf("unable to decode boolean value for field 'jedi' (tag=6): %w", err)
			} else {
				ov.Jedi = v
			}
			m.Path = &ov
		case 7: // path.sith (oneof,bool)
			var ov TestEvent_Sith
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'sith' (tag=7), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeBool(); err != nil {
				return fmt.Errorf("unable to decode boolean value for field 'sith' (tag=7): %w", err)
			} else {
				ov.Sith = v
			}
			m.Path = &ov
		case 8: // path.other (oneof,string)
			var ov TestEvent_Other
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for tag field 'other' (tag=8), expected 2 (length-delimited)", wt)
			}
			if s, err := dec.DecodeString(); err != nil {
				return fmt.Errorf("unable to decode string value for field 'other' (tag=8): %w", err)
			} else {
				ov.Other = s
			}
			m.Path = &ov
		case 12: // oneofs.timestamps (oneof,message)
			var ov TestEvent_Timestamps
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for tag field 'timestamps' (tag=12), expected 2 (length-delimited)", wt)
			}
			var mm_timestamps timestamppb.Timestamp
			if err = dec.DecodeNested(&mm_timestamps); err != nil {
				return fmt.Errorf("unable to decode message value for field 'timestamps' (tag=12): %w", err)
			} else {
				ov.Timestamps = &mm_timestamps
			}
			m.Oneofs = &ov
		case 13: // oneofs.structs (oneof,message)
			var ov TestEvent_Structs
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for tag field 'structs' (tag=13), expected 2 (length-delimited)", wt)
			}
			var mm_structs structpb.Struct
			if err = dec.DecodeNested(&mm_structs); err != nil {
				return fmt.Errorf("unable to decode message value for field 'structs' (tag=13): %w", err)
			} else {
				ov.Structs = &mm_structs
			}
			m.Oneofs = &ov
		default:
			if skipped, err := dec.Skip(tag, wt); err != nil {
				return fmt.Errorf("invalid operation skipping tag %v: %w", tag, err)
			} else {
				m.unknownFields = append(m.unknownFields, skipped...)
			}
		}
	}
	return nil
}

//------------------------------------------------------------------------------
// Custom Protobuf size/marshal/unmarshal code for EmbeddedEvent

// Size calculates and returns the size, in bytes, required to hold the contents of m using the Protobuf
// binary encoding.
func (m *EmbeddedEvent) Size() int {
	// nil message is always 0 bytes
	if m == nil {
		return 0
	}
	// return cached size, if present
	if csz := int(atomic.LoadInt32(&m.sizeCache)); csz > 0 {
		return csz
	}
	// calculate and cache
	var sz, l int
	_ = l // avoid unused variable

	// ID (int32,optional)
	if m.ID != 0 {
		sz += csproto.SizeOfTagKey(1) + csproto.SizeOfVarint(uint64(m.ID))
	}
	// Stuff (string,optional)
	if l = len(m.Stuff); l > 0 {
		sz += csproto.SizeOfTagKey(2) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// FavoriteNumbers (int32,repeated,packed)
	if len(m.FavoriteNumbers) > 0 {
		sz += csproto.SizeOfTagKey(3)
		l = 0
		for _, iv := range m.FavoriteNumbers {
			l += csproto.SizeOfVarint(uint64(iv))
		}
		sz += csproto.SizeOfVarint(uint64(l)) + l
	}
	// RandomThings (bytes,repeated)
	for _, bv := range m.RandomThings {
		l = len(bv)
		sz += csproto.SizeOfTagKey(4) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// cache the size so it can be re-used in Marshal()/MarshalTo()
	atomic.StoreInt32(&m.sizeCache, int32(sz))
	return sz
}

// Marshal converts the contents of m to the Protobuf binary encoding and returns the result or an error.
func (m *EmbeddedEvent) Marshal() ([]byte, error) {
	siz := m.Size()
	buf := make([]byte, siz)
	err := m.MarshalTo(buf)
	return buf, err
}

// MarshalTo converts the contents of m to the Protobuf binary encoding and writes the result to dest.
func (m *EmbeddedEvent) MarshalTo(dest []byte) error {
	var (
		enc    = csproto.NewEncoder(dest)
		buf    []byte
		err    error
		extVal interface{}
	)
	// ensure no unused variables
	_ = enc
	_ = buf
	_ = err
	_ = extVal

	// ID (1,int32,optional)
	if m.ID != 0 {
		enc.EncodeInt32(1, m.ID)
	}
	// Stuff (2,string,optional)
	if len(m.Stuff) > 0 {
		enc.EncodeString(2, m.Stuff)
	}
	// FavoriteNumbers (3,int32,repeated,packed)
	if len(m.FavoriteNumbers) > 0 {
		enc.EncodePackedInt32(3, m.FavoriteNumbers)
	}
	// RandomThings (4,bytes,repeated)
	for _, val := range m.RandomThings {
		enc.EncodeBytes(4, val)
	}
	return nil
}

// Unmarshal decodes a binary encoded Protobuf message from p and populates m with the result.
func (m *EmbeddedEvent) Unmarshal(p []byte) error {
	m.Reset()
	if len(p) == 0 {
		return nil
	}
	dec := csproto.NewDecoder(p)
	for dec.More() {
		tag, wt, err := dec.DecodeTag()
		if err != nil {
			return err
		}
		switch tag {
		case 1: // ID (int32,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'ID' (tag=1), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt32(); err != nil {
				return fmt.Errorf("unable to decode int32 value for field 'ID' (tag=1): %w", err)
			} else {
				m.ID = v
			}
		case 2: // Stuff (string,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'stuff' (tag=2), expected 2 (length-delimited)", wt)
			}
			if s, err := dec.DecodeString(); err != nil {
				return fmt.Errorf("unable to decode string value for field 'stuff' (tag=2): %w", err)
			} else {
				m.Stuff = s
			}

		case 3: // FavoriteNumbers (int32,repeated,packed)
			switch wt {
			case csproto.WireTypeVarint:
				if v, err := dec.DecodeInt32(); err != nil {
					return fmt.Errorf("unable to decode int32 value for field 'favoriteNumbers' (tag=3): %w", err)
				} else {
					m.FavoriteNumbers = append(m.FavoriteNumbers, v)
				}
			case csproto.WireTypeLengthDelimited:
				if v, err := dec.DecodePackedInt32(); err != nil {
					return fmt.Errorf("unable to decode packed int32 values for field 'favoriteNumbers' (tag=3): %w", err)
				} else {
					m.FavoriteNumbers = append(m.FavoriteNumbers, v...)
				}
			default:
				return fmt.Errorf("incorrect wire type %v for repeated field 'favoriteNumbers' (tag=3), expected 0 (varint) or 1 (length-delimited)", wt)
			}
		case 4: // RandomThings (bytes,repeated)

			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'randomThings' (tag=4), expected 2 (length-delimited)", wt)
			}
			if b, err := dec.DecodeBytes(); err != nil {
				return fmt.Errorf("unable to decode bytes value for field 'randomThings' (tag=4): %w", err)
			} else {
				m.RandomThings = append(m.RandomThings, b)
			}

		default:
			if skipped, err := dec.Skip(tag, wt); err != nil {
				return fmt.Errorf("invalid operation skipping tag %v: %w", tag, err)
			} else {
				m.unknownFields = append(m.unknownFields, skipped...)
			}
		}
	}
	return nil
}

//------------------------------------------------------------------------------
// Custom Protobuf size/marshal/unmarshal code for AllTheThings

// Size calculates and returns the size, in bytes, required to hold the contents of m using the Protobuf
// binary encoding.
func (m *AllTheThings) Size() int {
	// nil message is always 0 bytes
	if m == nil {
		return 0
	}
	// return cached size, if present
	if csz := int(atomic.LoadInt32(&m.sizeCache)); csz > 0 {
		return csz
	}
	// calculate and cache
	var sz, l int
	_ = l // avoid unused variable

	// ID (int32,optional)
	if m.ID != 0 {
		sz += csproto.SizeOfTagKey(1) + csproto.SizeOfVarint(uint64(m.ID))
	}
	// TheString (string,optional)
	if l = len(m.TheString); l > 0 {
		sz += csproto.SizeOfTagKey(2) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// TheBool (bool,optional)
	if m.TheBool {
		sz += csproto.SizeOfTagKey(3) + 1
	}
	// TheInt32 (int32,optional)
	if m.TheInt32 != 0 {
		sz += csproto.SizeOfTagKey(4) + csproto.SizeOfVarint(uint64(m.TheInt32))
	}
	// TheInt64 (int64,optional)
	if m.TheInt64 != 0 {
		sz += csproto.SizeOfTagKey(5) + csproto.SizeOfVarint(uint64(m.TheInt64))
	}
	// TheUInt32 (uint32,optional)
	if m.TheUInt32 != 0 {
		sz += csproto.SizeOfTagKey(6) + csproto.SizeOfVarint(uint64(m.TheUInt32))
	}
	// TheUInt64 (uint64,optional)
	if m.TheUInt64 != 0 {
		sz += csproto.SizeOfTagKey(7) + csproto.SizeOfVarint(uint64(m.TheUInt64))
	}
	// TheSInt32 (sint32,optional)
	if m.TheSInt32 != 0 {
		sz += csproto.SizeOfTagKey(8) + csproto.SizeOfZigZag(uint64(m.TheSInt32))
	}
	// TheSInt64 (sint64,optional)
	if m.TheSInt64 != 0 {
		sz += csproto.SizeOfTagKey(9) + csproto.SizeOfZigZag(uint64(m.TheSInt64))
	}
	// TheFixed32 (fixed32,optional)
	if m.TheFixed32 != 0 {
		sz += csproto.SizeOfTagKey(10) + 4
	}
	// TheFixed64 (fixed64,optional)
	if m.TheFixed64 != 0 {
		sz += csproto.SizeOfTagKey(11) + 8
	}
	// TheSFixed32 (sfixed32,optional)
	if m.TheSFixed32 != 0 {
		sz += csproto.SizeOfTagKey(12) + 4
	}
	// TheSFixed64 (sfixed64,optional)
	if m.TheSFixed64 != 0 {
		sz += csproto.SizeOfTagKey(13) + 8
	}
	// TheFloat (float,optional)
	if m.TheFloat != 0 {
		sz += csproto.SizeOfTagKey(14) + 4
	}
	// TheDouble (double,optional)
	if m.TheDouble != 0 {
		sz += csproto.SizeOfTagKey(15) + 8
	}
	// TheEventType (enum,optional)
	if m.TheEventType != 0 {
		sz += csproto.SizeOfTagKey(16) + csproto.SizeOfVarint(uint64(m.TheEventType))
	}
	// TheBytes (bytes,optional)
	if l = len(m.TheBytes); l > 0 {
		sz += csproto.SizeOfTagKey(17) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// TheMessage (message,optional)
	if m.TheMessage != nil {
		l = csproto.Size(m.TheMessage)
		sz += csproto.SizeOfTagKey(18) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// cache the size so it can be re-used in Marshal()/MarshalTo()
	atomic.StoreInt32(&m.sizeCache, int32(sz))
	return sz
}

// Marshal converts the contents of m to the Protobuf binary encoding and returns the result or an error.
func (m *AllTheThings) Marshal() ([]byte, error) {
	siz := m.Size()
	buf := make([]byte, siz)
	err := m.MarshalTo(buf)
	return buf, err
}

// MarshalTo converts the contents of m to the Protobuf binary encoding and writes the result to dest.
func (m *AllTheThings) MarshalTo(dest []byte) error {
	var (
		enc    = csproto.NewEncoder(dest)
		buf    []byte
		err    error
		extVal interface{}
	)
	// ensure no unused variables
	_ = enc
	_ = buf
	_ = err
	_ = extVal

	// ID (1,int32,optional)
	if m.ID != 0 {
		enc.EncodeInt32(1, m.ID)
	}
	// TheString (2,string,optional)
	if len(m.TheString) > 0 {
		enc.EncodeString(2, m.TheString)
	}
	// TheBool (3,bool,optional)
	if m.TheBool {
		enc.EncodeBool(3, m.TheBool)
	}
	// TheInt32 (4,int32,optional)
	if m.TheInt32 != 0 {
		enc.EncodeInt32(4, m.TheInt32)
	}
	// TheInt64 (5,int64,optional)
	if m.TheInt64 != 0 {
		enc.EncodeInt64(5, m.TheInt64)
	}
	// TheUInt32 (6,uint32,optional)
	if m.TheUInt32 != 0 {
		enc.EncodeUInt32(6, m.TheUInt32)
	}
	// TheUInt64 (7,uint64,optional)
	if m.TheUInt64 != 0 {
		enc.EncodeUInt64(7, m.TheUInt64)
	}
	// TheSInt32 (8,sint32,optional)
	if m.TheSInt32 != 0 {
		enc.EncodeSInt32(8, m.TheSInt32)
	}
	// TheSInt64 (9,sint64,optional)
	if m.TheSInt64 != 0 {
		enc.EncodeSInt64(9, m.TheSInt64)
	}
	// TheFixed32 (10,fixed32,optional)
	if m.TheFixed32 != 0 {
		enc.EncodeFixed32(10, m.TheFixed32)
	}
	// TheFixed64 (11,fixed64,optional)
	if m.TheFixed64 != 0 {
		enc.EncodeFixed64(11, m.TheFixed64)
	}
	// TheSFixed32 (12,sfixed32,optional)
	enc.EncodeFixed32(12, uint32(m.TheSFixed32))
	// TheSFixed64 (13,sfixed64,optional)
	enc.EncodeFixed64(13, uint64(m.TheSFixed64))
	// TheFloat (14,float,optional)
	if m.TheFloat != 0 {
		enc.EncodeFloat32(14, m.TheFloat)
	}
	// TheDouble (15,double,optional)
	if m.TheDouble != 0 {
		enc.EncodeFloat64(15, m.TheDouble)
	}
	// TheEventType (16,enum,optional)
	if m.TheEventType != 0 {
		enc.EncodeInt32(16, int32(m.TheEventType))
	}
	// TheBytes (17,bytes,optional)
	if len(m.TheBytes) > 0 {
		enc.EncodeBytes(17, m.TheBytes)
	}
	// TheMessage (18,message,optional)
	if m.TheMessage != nil {
		if err = enc.EncodeNested(18, m.TheMessage); err != nil {
			return fmt.Errorf("unable to encode message data for field 'theMessage' (tag=18): %w", err)
		}
	}
	return nil
}

// Unmarshal decodes a binary encoded Protobuf message from p and populates m with the result.
func (m *AllTheThings) Unmarshal(p []byte) error {
	m.Reset()
	if len(p) == 0 {
		return nil
	}
	dec := csproto.NewDecoder(p)
	for dec.More() {
		tag, wt, err := dec.DecodeTag()
		if err != nil {
			return err
		}
		switch tag {
		case 1: // ID (int32,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'ID' (tag=1), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt32(); err != nil {
				return fmt.Errorf("unable to decode int32 value for field 'ID' (tag=1): %w", err)
			} else {
				m.ID = v
			}
		case 2: // TheString (string,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'theString' (tag=2), expected 2 (length-delimited)", wt)
			}
			if s, err := dec.DecodeString(); err != nil {
				return fmt.Errorf("unable to decode string value for field 'theString' (tag=2): %w", err)
			} else {
				m.TheString = s
			}

		case 3: // TheBool (bool,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'theBool' (tag=3), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeBool(); err != nil {
				return fmt.Errorf("unable to decode boolean value for field 'theBool' (tag=3): %w", err)
			} else {
				m.TheBool = v
			}
		case 4: // TheInt32 (int32,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'theInt32' (tag=4), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt32(); err != nil {
				return fmt.Errorf("unable to decode int32 value for field 'theInt32' (tag=4): %w", err)
			} else {
				m.TheInt32 = v
			}
		case 5: // TheInt64 (int64,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'theInt64' (tag=5), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt64(); err != nil {
				return fmt.Errorf("unable to decode int64 value for field 'theInt64' (tag=5): %w", err)
			} else {
				m.TheInt64 = v
			}
		case 6: // TheUInt32 (uint32,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'theUInt32' (tag=6), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeUInt32(); err != nil {
				return fmt.Errorf("unable to decode int32 value for field 'theUInt32' (tag=6): %w", err)
			} else {
				m.TheUInt32 = v
			}
		case 7: // TheUInt64 (uint64,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'theUInt64' (tag=7), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeUInt64(); err != nil {
				return fmt.Errorf("unable to decode uint64 value for field 'theUInt64' (tag=7): %w", err)
			} else {
				m.TheUInt64 = v
			}
		case 8: // TheSInt32 (sint32,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'theSInt32' (tag=8), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeSInt32(); err != nil {
				return fmt.Errorf("unable to decode sint32 value for field 'theSInt32' (tag=8): %w", err)
			} else {
				m.TheSInt32 = v
			}
		case 9: // TheSInt64 (sint64,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'theSInt64' (tag=9), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeSInt64(); err != nil {
				return fmt.Errorf("unable to decode sint64 value for field 'theSInt64' (tag=9): %w", err)
			} else {
				m.TheSInt64 = v
			}
		case 10: // TheFixed32 (fixed32,optional)
			if wt != csproto.WireTypeFixed32 {
				return fmt.Errorf("incorrect wire type %v for tag field 'theFixed32' (tag=10), expected 5 (32-bit)", wt)
			}
			if v, err := dec.DecodeFixed32(); err != nil {
				return fmt.Errorf("unable to decode uint32 value for field 'theFixed32' (tag=10): %w", err)
			} else {
				m.TheFixed32 = v
			}
		case 11: // TheFixed64 (fixed64,optional)
			if wt != csproto.WireTypeFixed64 {
				return fmt.Errorf("incorrect wire type %v for tag field 'theFixed64' (tag=11), expected 1 (64-bit)", wt)
			}
			if v, err := dec.DecodeFixed64(); err != nil {
				return fmt.Errorf("unable to decode uint64 value for field 'theFixed64' (tag=11): %w", err)
			} else {
				m.TheFixed64 = v
			}
		case 12: // TheSFixed32 (sfixed32,optional)
			if wt != csproto.WireTypeFixed32 {
				return fmt.Errorf("incorrect wire type %v for field 'theSFixed32' (tag=12), expected 5 (32-bit)", wt)
			}
			if v, err := dec.DecodeFixed32(); err != nil {
				return fmt.Errorf("unable to decode sfixed32 value for field 'theSFixed32' (tag=12): %w", err)
			} else {
				m.TheSFixed32 = int32(v)
			}

		case 13: // TheSFixed64 (sfixed64,optional)
			if wt != csproto.WireTypeFixed64 {
				return fmt.Errorf("incorrect wire type %v for field 'theSFixed64' (tag=13), expected 1 (64-bit)", wt)
			}
			if v, err := dec.DecodeFixed64(); err != nil {
				return fmt.Errorf("unable to decode sfixed64 value for field 'theSFixed64' (tag=13): %w", err)
			} else {
				m.TheSFixed64 = int64(v)
			}

		case 14: // TheFloat (float,optional)
			if wt != csproto.WireTypeFixed32 {
				return fmt.Errorf("incorrect wire type %v for tag field 'theFloat' (tag=14), expected 5 (32-bit)", wt)
			}
			if v, err := dec.DecodeFloat32(); err != nil {
				return fmt.Errorf("unable to decode float value for field 'theFloat' (tag=14): %w", err)
			} else {
				m.TheFloat = v
			}
		case 15: // TheDouble (double,optional)
			if wt != csproto.WireTypeFixed64 {
				return fmt.Errorf("incorrect wire type %v for tag field 'theDouble' (tag=15), expected 1 (64-bit)", wt)
			}
			if v, err := dec.DecodeFloat64(); err != nil {
				return fmt.Errorf("unable to decode double value for field 'theDouble' (tag=15): %w", err)
			} else {
				m.TheDouble = v
			}
		case 16: // TheEventType (enum,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'theEventType' (tag=16), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt32(); err != nil {
				return fmt.Errorf("unable to decode int32 enum value for field 'theEventType' (tag=16): %w", err)
			} else {
				m.TheEventType = EventType(v)
			}
		case 17: // TheBytes (bytes,optional)

			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'theBytes' (tag=17), expected 2 (length-delimited)", wt)
			}
			if b, err := dec.DecodeBytes(); err != nil {
				return fmt.Errorf("unable to decode bytes value for field 'theBytes' (tag=17): %w", err)
			} else {
				m.TheBytes = b
			}

		case 18: // TheMessage (message,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'theMessage' (tag=18), expected 2 (length-delimited)", wt)
			}
			var mm EmbeddedEvent
			if err = dec.DecodeNested(&mm); err != nil {
				return fmt.Errorf("unable to decode message value for field 'theMessage' (tag=18): %w", err)
			}
			m.TheMessage = &mm

		default:
			if skipped, err := dec.Skip(tag, wt); err != nil {
				return fmt.Errorf("invalid operation skipping tag %v: %w", tag, err)
			} else {
				m.unknownFields = append(m.unknownFields, skipped...)
			}
		}
	}
	return nil
}

//------------------------------------------------------------------------------
// Custom Protobuf size/marshal/unmarshal code for RepeatAllTheThings

// Size calculates and returns the size, in bytes, required to hold the contents of m using the Protobuf
// binary encoding.
func (m *RepeatAllTheThings) Size() int {
	// nil message is always 0 bytes
	if m == nil {
		return 0
	}
	// return cached size, if present
	if csz := int(atomic.LoadInt32(&m.sizeCache)); csz > 0 {
		return csz
	}
	// calculate and cache
	var sz, l int
	_ = l // avoid unused variable

	// ID (int32,optional)
	if m.ID != 0 {
		sz += csproto.SizeOfTagKey(1) + csproto.SizeOfVarint(uint64(m.ID))
	}
	// TheStrings (string,repeated)
	for _, sv := range m.TheStrings {
		l = len(sv)
		sz += csproto.SizeOfTagKey(2) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// TheBools (bool,repeated,packed)
	if l = len(m.TheBools); l > 0 {
		sz += csproto.SizeOfTagKey(3) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// TheInt32S (int32,repeated,packed)
	if len(m.TheInt32S) > 0 {
		sz += csproto.SizeOfTagKey(4)
		l = 0
		for _, iv := range m.TheInt32S {
			l += csproto.SizeOfVarint(uint64(iv))
		}
		sz += csproto.SizeOfVarint(uint64(l)) + l
	}
	// TheInt64S (int64,repeated,packed)
	if len(m.TheInt64S) > 0 {
		sz += csproto.SizeOfTagKey(5)
		l = 0
		for _, iv := range m.TheInt64S {
			l += csproto.SizeOfVarint(uint64(iv))
		}
		sz += csproto.SizeOfVarint(uint64(l)) + l
	}
	// TheUInt32S (uint32,repeated,packed)
	if len(m.TheUInt32S) > 0 {
		sz += csproto.SizeOfTagKey(6)
		l = 0
		for _, iv := range m.TheUInt32S {
			l += csproto.SizeOfVarint(uint64(iv))
		}
		sz += csproto.SizeOfVarint(uint64(l)) + l
	}
	// TheUInt64S (uint64,repeated,packed)
	if len(m.TheUInt64S) > 0 {
		sz += csproto.SizeOfTagKey(7)
		l = 0
		for _, iv := range m.TheUInt64S {
			l += csproto.SizeOfVarint(uint64(iv))
		}
		sz += csproto.SizeOfVarint(uint64(l)) + l
	}
	// TheSInt32S (sint32,repeated,packed)
	if len(m.TheSInt32S) > 0 {
		sz += csproto.SizeOfTagKey(8)
		l = 0
		for _, iv := range m.TheSInt32S {
			l += csproto.SizeOfZigZag(uint64(iv))
		}
		sz += csproto.SizeOfVarint(uint64(l)) + l
	}
	// TheSInt64S (sint64,repeated,packed)
	if len(m.TheSInt64S) > 0 {
		sz += csproto.SizeOfTagKey(9)
		l = 0
		for _, iv := range m.TheSInt64S {
			l += csproto.SizeOfZigZag(uint64(iv))
		}
		sz += csproto.SizeOfVarint(uint64(l)) + l
	}
	// TheFixed32S (fixed32,repeated,packed)
	if l = len(m.TheFixed32S); l > 0 {
		sz += csproto.SizeOfTagKey(10) + csproto.SizeOfVarint(uint64(l)) + (l * 4)
	}
	// TheFixed64S (fixed64,repeated,packed)
	if l = len(m.TheFixed64S); l > 0 {
		sz += csproto.SizeOfTagKey(11) + csproto.SizeOfVarint(uint64(l)) + (l * 8)
	}
	// TheSFixed32S (sfixed32,repeated,packed)
	if l = len(m.TheSFixed32S); l > 0 {
		sz += csproto.SizeOfTagKey(12) + csproto.SizeOfVarint(uint64(l)) + (l * 4)
	}
	// TheSFixed64S (sfixed64,repeated,packed)
	if l = len(m.TheSFixed64S); l > 0 {
		sz += csproto.SizeOfTagKey(13) + csproto.SizeOfVarint(uint64(l)) + (l * 8)
	}
	// TheFloats (float,repeated,packed)
	if l = len(m.TheFloats); l > 0 {
		sz += csproto.SizeOfTagKey(14) + csproto.SizeOfVarint(uint64(l)) + (l * 4)
	}
	// TheDoubles (double,repeated,packed)
	if l = len(m.TheDoubles); l > 0 {
		sz += csproto.SizeOfTagKey(15) + csproto.SizeOfVarint(uint64(l)) + (l * 8)
	}
	// TheEventTypes (enum,repeated,packed)
	if len(m.TheEventTypes) > 0 {
		sz += csproto.SizeOfTagKey(16)
		l = 0
		for _, iv := range m.TheEventTypes {
			l += csproto.SizeOfVarint(uint64(iv))
		}
		sz += csproto.SizeOfVarint(uint64(l)) + l
	}
	// TheBytes (bytes,repeated)
	for _, bv := range m.TheBytes {
		l = len(bv)
		sz += csproto.SizeOfTagKey(17) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// TheMessages (message,repeated)
	for _, val := range m.TheMessages {
		if l = csproto.Size(val); l > 0 {
			sz += csproto.SizeOfTagKey(18) + csproto.SizeOfVarint(uint64(l)) + l
		}
	}
	// cache the size so it can be re-used in Marshal()/MarshalTo()
	atomic.StoreInt32(&m.sizeCache, int32(sz))
	return sz
}

// Marshal converts the contents of m to the Protobuf binary encoding and returns the result or an error.
func (m *RepeatAllTheThings) Marshal() ([]byte, error) {
	siz := m.Size()
	buf := make([]byte, siz)
	err := m.MarshalTo(buf)
	return buf, err
}

// MarshalTo converts the contents of m to the Protobuf binary encoding and writes the result to dest.
func (m *RepeatAllTheThings) MarshalTo(dest []byte) error {
	var (
		enc    = csproto.NewEncoder(dest)
		buf    []byte
		err    error
		extVal interface{}
	)
	// ensure no unused variables
	_ = enc
	_ = buf
	_ = err
	_ = extVal

	// ID (1,int32,optional)
	if m.ID != 0 {
		enc.EncodeInt32(1, m.ID)
	}
	// TheStrings (2,string,repeated)
	for _, val := range m.TheStrings {
		enc.EncodeString(2, val)
	}
	// TheBools (3,bool,repeated,packed)
	if len(m.TheBools) > 0 {
		enc.EncodePackedBool(3, m.TheBools)
	}
	// TheInt32S (4,int32,repeated,packed)
	if len(m.TheInt32S) > 0 {
		enc.EncodePackedInt32(4, m.TheInt32S)
	}
	// TheInt64S (5,int64,repeated,packed)
	if len(m.TheInt64S) > 0 {
		enc.EncodePackedInt64(5, m.TheInt64S)
	}
	// TheUInt32S (6,uint32,repeated,packed)
	if len(m.TheUInt32S) > 0 {
		enc.EncodePackedUInt32(6, m.TheUInt32S)
	}
	// TheUInt64S (7,uint64,repeated,packed)
	if len(m.TheUInt64S) > 0 {
		enc.EncodePackedUInt64(7, m.TheUInt64S)
	}
	// TheSInt32S (8,sint32,repeated,packed)
	if len(m.TheSInt32S) > 0 {
		enc.EncodePackedSInt32(8, m.TheSInt32S)
	}
	// TheSInt64S (9,sint64,repeated,packed)
	if len(m.TheSInt64S) > 0 {
		enc.EncodePackedSInt64(9, m.TheSInt64S)
	}
	// TheFixed32S (10,fixed32,repeated,packed)
	if len(m.TheFixed32S) > 0 {
		enc.EncodePackedFixed32(10, m.TheFixed32S)
	}
	// TheFixed64S (11,fixed64,repeated,packed)
	if len(m.TheFixed64S) > 0 {
		enc.EncodePackedFixed64(11, m.TheFixed64S)
	}
	// TheSFixed32S (12,sfixed32,repeated,packed)
	if len(m.TheSFixed32S) > 0 {
		enc.EncodePackedSFixed32(12, m.TheSFixed32S)
	}
	// TheSFixed64S (13,sfixed64,repeated,packed)
	if len(m.TheSFixed64S) > 0 {
		enc.EncodePackedSFixed64(13, m.TheSFixed64S)
	}
	// TheFloats (14,float,repeated,packed)
	if len(m.TheFloats) > 0 {
		enc.EncodePackedFloat32(14, m.TheFloats)
	}
	// TheDoubles (15,double,repeated,packed)
	if len(m.TheDoubles) > 0 {
		enc.EncodePackedFloat64(15, m.TheDoubles)
	}
	// TheEventTypes (16,enum,repeated,packed)
	if l := len(m.TheEventTypes); l > 0 {
		ivs := make([]int32, l)
		for i, v := range m.TheEventTypes {
			ivs[i] = int32(v)
		}
		enc.EncodePackedInt32(16, ivs)
	}
	// TheBytes (17,bytes,repeated)
	for _, val := range m.TheBytes {
		enc.EncodeBytes(17, val)
	}
	// TheMessages (18,message,repeated)
	for _, mm := range m.TheMessages {
		if err = enc.EncodeNested(18, mm); err != nil {
			return fmt.Errorf("unable to encode message data for field 'theMessages' (tag=18): %w", err)
		}
	}
	return nil
}

// Unmarshal decodes a binary encoded Protobuf message from p and populates m with the result.
func (m *RepeatAllTheThings) Unmarshal(p []byte) error {
	m.Reset()
	if len(p) == 0 {
		return nil
	}
	dec := csproto.NewDecoder(p)
	for dec.More() {
		tag, wt, err := dec.DecodeTag()
		if err != nil {
			return err
		}
		switch tag {
		case 1: // ID (int32,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'ID' (tag=1), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt32(); err != nil {
				return fmt.Errorf("unable to decode int32 value for field 'ID' (tag=1): %w", err)
			} else {
				m.ID = v
			}
		case 2: // TheStrings (string,repeated)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'theStrings' (tag=2), expected 2 (length-delimited)", wt)
			}
			if s, err := dec.DecodeString(); err != nil {
				return fmt.Errorf("unable to decode string value for field 'theStrings' (tag=2): %w", err)
			} else {
				m.TheStrings = append(m.TheStrings, s)
			}

		case 3: // TheBools (bool,repeated,packed)
			switch wt {
			case csproto.WireTypeVarint:
				if v, err := dec.DecodeBool(); err != nil {
					return fmt.Errorf("unable to decode boolean value for field 'theBools' (tag=3): %w", err)
				} else {
					m.TheBools = append(m.TheBools, v)
				}
			case csproto.WireTypeLengthDelimited:
				if v, err := dec.DecodePackedBool(); err != nil {
					return fmt.Errorf("unable to decode packed boolean values for field 'theBools' (tag=3): %w", err)
				} else {
					m.TheBools = append(m.TheBools, v...)
				}
			default:
				return fmt.Errorf("incorrect wire type %v for repeated field 'theBools' (tag=3), expected 0 (varint) or 1 (length-delimited)", wt)
			}
		case 4: // TheInt32S (int32,repeated,packed)
			switch wt {
			case csproto.WireTypeVarint:
				if v, err := dec.DecodeInt32(); err != nil {
					return fmt.Errorf("unable to decode int32 value for field 'theInt32s' (tag=4): %w", err)
				} else {
					m.TheInt32S = append(m.TheInt32S, v)
				}
			case csproto.WireTypeLengthDelimited:
				if v, err := dec.DecodePackedInt32(); err != nil {
					return fmt.Errorf("unable to decode packed int32 values for field 'theInt32s' (tag=4): %w", err)
				} else {
					m.TheInt32S = append(m.TheInt32S, v...)
				}
			default:
				return fmt.Errorf("incorrect wire type %v for repeated field 'theInt32s' (tag=4), expected 0 (varint) or 1 (length-delimited)", wt)
			}
		case 5: // TheInt64S (int64,repeated,packed)
			switch wt {
			case csproto.WireTypeVarint:
				if v, err := dec.DecodeInt64(); err != nil {
					return fmt.Errorf("unable to decode int64 value for field 'theInt64s' (tag=5): %w", err)
				} else {
					m.TheInt64S = append(m.TheInt64S, v)
				}
			case csproto.WireTypeLengthDelimited:
				if v, err := dec.DecodePackedInt64(); err != nil {
					return fmt.Errorf("unable to decode packed int64 values for field 'theInt64s' (tag=5): %w", err)
				} else {
					m.TheInt64S = append(m.TheInt64S, v...)
				}
			default:
				return fmt.Errorf("incorrect wire type %v for repeated field 'theInt64s' (tag=5), expected 0 (varint) or 1 (length-delimited)", wt)
			}
		case 6: // TheUInt32S (uint32,repeated,packed)
			switch wt {
			case csproto.WireTypeVarint:
				if v, err := dec.DecodeUInt32(); err != nil {
					return fmt.Errorf("unable to decode uint32 value for field 'theUInt32s' (tag=6): %w", err)
				} else {
					m.TheUInt32S = append(m.TheUInt32S, v)
				}
			case csproto.WireTypeLengthDelimited:
				if v, err := dec.DecodePackedUint32(); err != nil {
					return fmt.Errorf("unable to decode packed uint32 values for field 'theUInt32s' (tag=6): %w", err)
				} else {
					m.TheUInt32S = append(m.TheUInt32S, v...)
				}
			default:
				return fmt.Errorf("incorrect wire type %v for repeated field 'theUInt32s' (tag=6), expected 0 (varint) or 1 (length-delimited)", wt)
			}
		case 7: // TheUInt64S (uint64,repeated,packed)
			switch wt {
			case csproto.WireTypeVarint:
				if v, err := dec.DecodeUInt64(); err != nil {
					return fmt.Errorf("unable to decode uint64 value for field 'theUInt64s' (tag=7): %w", err)
				} else {
					m.TheUInt64S = append(m.TheUInt64S, v)
				}
			case csproto.WireTypeLengthDelimited:
				if v, err := dec.DecodePackedUint64(); err != nil {
					return fmt.Errorf("unable to decode packed uint64 values for field 'theUInt64s' (tag=7): %w", err)
				} else {
					m.TheUInt64S = append(m.TheUInt64S, v...)
				}
			default:
				return fmt.Errorf("incorrect wire type %v for repeated field 'theUInt64s' (tag=7), expected 0 (varint) or 1 (length-delimited)", wt)
			}
		case 8: // TheSInt32S (sint32,repeated,packed)
			switch wt {
			case csproto.WireTypeVarint:
				if v, err := dec.DecodeSInt32(); err != nil {
					return fmt.Errorf("unable to decode sint32 value for field 'theSInt32s' (tag=8): %w", err)
				} else {
					m.TheSInt32S = append(m.TheSInt32S, v)
				}
			case csproto.WireTypeLengthDelimited:
				if v, err := dec.DecodePackedSint32(); err != nil {
					return fmt.Errorf("unable to decode packed sint32 values for field 'theSInt32s' (tag=8): %w", err)
				} else {
					m.TheSInt32S = append(m.TheSInt32S, v...)
				}
			default:
				return fmt.Errorf("incorrect wire type %v for repeated field 'theSInt32s' (tag=8), expected 0 (varint) or 1 (length-delimited)", wt)
			}
		case 9: // TheSInt64S (sint64,repeated,packed)
			switch wt {
			case csproto.WireTypeVarint:
				if v, err := dec.DecodeSInt64(); err != nil {
					return fmt.Errorf("unable to decode sint64 value for field 'theSInt64s' (tag=9): %w", err)
				} else {
					m.TheSInt64S = append(m.TheSInt64S, v)
				}
			case csproto.WireTypeLengthDelimited:
				if v, err := dec.DecodePackedSint64(); err != nil {
					return fmt.Errorf("unable to decode packed sint64 values for field 'theSInt64s' (tag=9): %w", err)
				} else {
					m.TheSInt64S = append(m.TheSInt64S, v...)
				}
			default:
				return fmt.Errorf("incorrect wire type %v for repeated field 'theSInt64s' (tag=9), expected 0 (varint) or 1 (length-delimited)", wt)
			}
		case 10: // TheFixed32S (fixed32,repeated,packed)
			switch wt {
			case csproto.WireTypeFixed32:
				if v, err := dec.DecodeFixed32(); err != nil {
					return fmt.Errorf("unable to decode uint32 value for field 'theFixed32s' (tag=10): %w", err)
				} else {
					m.TheFixed32S = append(m.TheFixed32S, v)
				}
			case csproto.WireTypeLengthDelimited:
				if v, err := dec.DecodePackedFixed32(); err != nil {
					return fmt.Errorf("unable to decode packed uint32 values for field 'theFixed32s' (tag=10): %w", err)
				} else {
					m.TheFixed32S = append(m.TheFixed32S, v...)
				}
			default:
				return fmt.Errorf("incorrect wire type %v for repeated field 'theFixed32s' (tag=10), expected 5 (32-bit) or 1 (length-delimited)", wt)
			}
		case 11: // TheFixed64S (fixed64,repeated,packed)
			switch wt {
			case csproto.WireTypeFixed64:
				if v, err := dec.DecodeFixed64(); err != nil {
					return fmt.Errorf("unable to decode uint64 value for field 'theFixed64s' (tag=11): %w", err)
				} else {
					m.TheFixed64S = append(m.TheFixed64S, v)
				}
			case csproto.WireTypeLengthDelimited:
				if v, err := dec.DecodePackedFixed64(); err != nil {
					return fmt.Errorf("unable to decode packed uint64 values for field 'theFixed64s' (tag=11): %w", err)
				} else {
					m.TheFixed64S = append(m.TheFixed64S, v...)
				}
			default:
				return fmt.Errorf("incorrect wire type %v for repeated field 'theFixed64s' (tag=11), expected 1 (64-bit) or 1 (length-delimited)", wt)
			}
		case 12: // TheSFixed32S (sfixed32,repeated,packed)
			if wt != csproto.WireTypeFixed32 {
				return fmt.Errorf("incorrect wire type %v for field 'theSFixed32s' (tag=12), expected 5 (32-bit)", wt)
			}
			if v, err := dec.DecodeFixed32(); err != nil {
				return fmt.Errorf("unable to decode sfixed32 value for field 'theSFixed32s' (tag=12): %w", err)
			} else {
				m.TheSFixed32S = append(m.TheSFixed32S, int32(v))
			}

		case 13: // TheSFixed64S (sfixed64,repeated,packed)
			if wt != csproto.WireTypeFixed64 {
				return fmt.Errorf("incorrect wire type %v for field 'theSFixed64s' (tag=13), expected 1 (64-bit)", wt)
			}
			if v, err := dec.DecodeFixed64(); err != nil {
				return fmt.Errorf("unable to decode sfixed64 value for field 'theSFixed64s' (tag=13): %w", err)
			} else {
				m.TheSFixed64S = append(m.TheSFixed64S, int64(v))
			}

		case 14: // TheFloats (float,repeated,packed)
			switch wt {
			case csproto.WireTypeFixed32:
				if v, err := dec.DecodeFloat32(); err != nil {
					return fmt.Errorf("unable to decode float value for field 'theFloats' (tag=14): %w", err)
				} else {
					m.TheFloats = append(m.TheFloats, v)
				}
			case csproto.WireTypeLengthDelimited:
				if v, err := dec.DecodePackedFloat32(); err != nil {
					return fmt.Errorf("unable to decode packed float values for field 'theFloats' (tag=14): %w", err)
				} else {
					m.TheFloats = append(m.TheFloats, v...)
				}
			default:
				return fmt.Errorf("incorrect wire type %v for repeated field 'theFloats' (tag=14), expected 5 (32-bit) or 1 (length-delimited)", wt)
			}
		case 15: // TheDoubles (double,repeated,packed)
			switch wt {
			case csproto.WireTypeFixed64:
				if v, err := dec.DecodeFloat64(); err != nil {
					return fmt.Errorf("unable to decode double value for field 'theDoubles' (tag=15): %w", err)
				} else {
					m.TheDoubles = append(m.TheDoubles, v)
				}
			case csproto.WireTypeLengthDelimited:
				if v, err := dec.DecodePackedFloat64(); err != nil {
					return fmt.Errorf("unable to decode packed double values for field 'theDoubles' (tag=15): %w", err)
				} else {
					m.TheDoubles = append(m.TheDoubles, v...)
				}
			default:
				return fmt.Errorf("incorrect wire type %v for repeated field 'theDoubles' (tag=15), expected 1 (64-bit) or 1 (length-delimited)", wt)
			}
		case 16: // TheEventTypes (enum,repeated,packed)
			switch wt {
			case csproto.WireTypeVarint:
				if v, err := dec.DecodeInt32(); err != nil {
					return fmt.Errorf("unable to decode int32 enum value for field 'theEventTypes' (tag=16): %w", err)
				} else {
					m.TheEventTypes = append(m.TheEventTypes, EventType(v))
				}
			case csproto.WireTypeLengthDelimited:
				if v, err := dec.DecodePackedInt32(); err != nil {
					return fmt.Errorf("unable to decode packed int32 enum values for field 'theEventTypes' (tag=16): %w", err)
				} else {
					for _, elem := range v {
						m.TheEventTypes = append(m.TheEventTypes, EventType(elem))
					}
				}
			default:
				return fmt.Errorf("incorrect wire type %v for repeated field 'theEventTypes' (tag=16), expected 0 (varint) or 1 (length-delimited)", wt)
			}
		case 17: // TheBytes (bytes,repeated)

			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'theBytes' (tag=17), expected 2 (length-delimited)", wt)
			}
			if b, err := dec.DecodeBytes(); err != nil {
				return fmt.Errorf("unable to decode bytes value for field 'theBytes' (tag=17): %w", err)
			} else {
				m.TheBytes = append(m.TheBytes, b)
			}

		case 18: // TheMessages (message,repeated)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'theMessages' (tag=18), expected 2 (length-delimited)", wt)
			}
			var mm EmbeddedEvent
			if err = dec.DecodeNested(&mm); err != nil {
				return fmt.Errorf("unable to decode message value for field 'theMessages' (tag=18): %w", err)
			}
			m.TheMessages = append(m.TheMessages, &mm)

		default:
			if skipped, err := dec.Skip(tag, wt); err != nil {
				return fmt.Errorf("invalid operation skipping tag %v: %w", tag, err)
			} else {
				m.unknownFields = append(m.unknownFields, skipped...)
			}
		}
	}
	return nil
}

//------------------------------------------------------------------------------
// Custom Protobuf size/marshal/unmarshal code for EventUsingWKTs

// Size calculates and returns the size, in bytes, required to hold the contents of m using the Protobuf
// binary encoding.
func (m *EventUsingWKTs) Size() int {
	// nil message is always 0 bytes
	if m == nil {
		return 0
	}
	// return cached size, if present
	if csz := int(atomic.LoadInt32(&m.sizeCache)); csz > 0 {
		return csz
	}
	// calculate and cache
	var sz, l int
	_ = l // avoid unused variable

	// Name (string,optional)
	if l = len(m.Name); l > 0 {
		sz += csproto.SizeOfTagKey(1) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// Ts (message,optional)
	if m.Ts != nil {
		l = csproto.Size(m.Ts)
		sz += csproto.SizeOfTagKey(2) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// EventType (enum,optional)
	if m.EventType != 0 {
		sz += csproto.SizeOfTagKey(3) + csproto.SizeOfVarint(uint64(m.EventType))
	}
	// cache the size so it can be re-used in Marshal()/MarshalTo()
	atomic.StoreInt32(&m.sizeCache, int32(sz))
	return sz
}

// Marshal converts the contents of m to the Protobuf binary encoding and returns the result or an error.
func (m *EventUsingWKTs) Marshal() ([]byte, error) {
	siz := m.Size()
	buf := make([]byte, siz)
	err := m.MarshalTo(buf)
	return buf, err
}

// MarshalTo converts the contents of m to the Protobuf binary encoding and writes the result to dest.
func (m *EventUsingWKTs) MarshalTo(dest []byte) error {
	var (
		enc    = csproto.NewEncoder(dest)
		buf    []byte
		err    error
		extVal interface{}
	)
	// ensure no unused variables
	_ = enc
	_ = buf
	_ = err
	_ = extVal

	// Name (1,string,optional)
	if len(m.Name) > 0 {
		enc.EncodeString(1, m.Name)
	}
	// Ts (2,message,optional)
	if m.Ts != nil {
		if err = enc.EncodeNested(2, m.Ts); err != nil {
			return fmt.Errorf("unable to encode message data for field 'ts' (tag=2): %w", err)
		}
	}
	// EventType (3,enum,optional)
	if m.EventType != 0 {
		enc.EncodeInt32(3, int32(m.EventType))
	}
	return nil
}

// Unmarshal decodes a binary encoded Protobuf message from p and populates m with the result.
func (m *EventUsingWKTs) Unmarshal(p []byte) error {
	m.Reset()
	if len(p) == 0 {
		return nil
	}
	dec := csproto.NewDecoder(p)
	for dec.More() {
		tag, wt, err := dec.DecodeTag()
		if err != nil {
			return err
		}
		switch tag {
		case 1: // Name (string,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'name' (tag=1), expected 2 (length-delimited)", wt)
			}
			if s, err := dec.DecodeString(); err != nil {
				return fmt.Errorf("unable to decode string value for field 'name' (tag=1): %w", err)
			} else {
				m.Name = s
			}

		case 2: // Ts (message,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'ts' (tag=2), expected 2 (length-delimited)", wt)
			}
			var mm timestamppb.Timestamp
			if err = dec.DecodeNested(&mm); err != nil {
				return fmt.Errorf("unable to decode message value for field 'ts' (tag=2): %w", err)
			}
			m.Ts = &mm
		case 3: // EventType (enum,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'event_type' (tag=3), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt32(); err != nil {
				return fmt.Errorf("unable to decode int32 enum value for field 'event_type' (tag=3): %w", err)
			} else {
				m.EventType = EventType(v)
			}

		default:
			if skipped, err := dec.Skip(tag, wt); err != nil {
				return fmt.Errorf("invalid operation skipping tag %v: %w", tag, err)
			} else {
				m.unknownFields = append(m.unknownFields, skipped...)
			}
		}
	}
	return nil
}

//------------------------------------------------------------------------------
// Custom Protobuf size/marshal/unmarshal code for MapObject

// Size calculates and returns the size, in bytes, required to hold the contents of m using the Protobuf
// binary encoding.
func (m *MapObject) Size() int {
	// nil message is always 0 bytes
	if m == nil {
		return 0
	}
	// return cached size, if present
	if csz := int(atomic.LoadInt32(&m.sizeCache)); csz > 0 {
		return csz
	}
	// calculate and cache
	var sz, l int
	_ = l // avoid unused variable

	// Name (string,optional)
	if l = len(m.Name); l > 0 {
		sz += csproto.SizeOfTagKey(1) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// Ts (message,optional)
	if m.Ts != nil {
		l = csproto.Size(m.Ts)
		sz += csproto.SizeOfTagKey(2) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// Attributes (message,repeated)
	for k, v := range m.Attributes {
		// size of key (always has an internal tag of 1)
		l = len(k)
		keySize := 1 + csproto.SizeOfVarint(uint64(l)) + l
		// size of value (always has an internal tag of 2)
		l = len(v)
		valueSize := 1 + csproto.SizeOfVarint(uint64(l)) + l
		sz += csproto.SizeOfTagKey(3) + csproto.SizeOfVarint(uint64(keySize+valueSize)) + keySize + valueSize
	}

	// cache the size so it can be re-used in Marshal()/MarshalTo()
	atomic.StoreInt32(&m.sizeCache, int32(sz))
	return sz
}

// Marshal converts the contents of m to the Protobuf binary encoding and returns the result or an error.
func (m *MapObject) Marshal() ([]byte, error) {
	siz := m.Size()
	buf := make([]byte, siz)
	err := m.MarshalTo(buf)
	return buf, err
}

// MarshalTo converts the contents of m to the Protobuf binary encoding and writes the result to dest.
func (m *MapObject) MarshalTo(dest []byte) error {
	var (
		enc    = csproto.NewEncoder(dest)
		buf    []byte
		err    error
		extVal interface{}
	)
	// ensure no unused variables
	_ = enc
	_ = buf
	_ = err
	_ = extVal

	// Name (1,string,optional)
	if len(m.Name) > 0 {
		enc.EncodeString(1, m.Name)
	}
	// Ts (2,message,optional)
	if m.Ts != nil {
		if err = enc.EncodeNested(2, m.Ts); err != nil {
			return fmt.Errorf("unable to encode message data for field 'ts' (tag=2): %w", err)
		}
	}
	// Attributes (3,map)
	for k, v := range m.Attributes {
		valueSize := len(v)
		itemSize := 1 + csproto.SizeOfVarint(uint64(valueSize)) + valueSize
		keySize := len(k)
		itemSize += 1 + csproto.SizeOfVarint(uint64(keySize)) + keySize
		enc.EncodeMapEntryHeader(3, itemSize)
		enc.EncodeString(1, k)
		enc.EncodeString(2, v)
	}

	return nil
}

// Unmarshal decodes a binary encoded Protobuf message from p and populates m with the result.
func (m *MapObject) Unmarshal(p []byte) error {
	m.Reset()
	if len(p) == 0 {
		return nil
	}
	dec := csproto.NewDecoder(p)
	for dec.More() {
		tag, wt, err := dec.DecodeTag()
		if err != nil {
			return err
		}
		switch tag {
		case 1: // Name (string,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'name' (tag=1), expected 2 (length-delimited)", wt)
			}
			if s, err := dec.DecodeString(); err != nil {
				return fmt.Errorf("unable to decode string value for field 'name' (tag=1): %w", err)
			} else {
				m.Name = s
			}

		case 2: // Ts (message,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'ts' (tag=2), expected 2 (length-delimited)", wt)
			}
			var mm timestamppb.Timestamp
			if err = dec.DecodeNested(&mm); err != nil {
				return fmt.Errorf("unable to decode message value for field 'ts' (tag=2): %w", err)
			}
			m.Ts = &mm
		case 3: // Attributes (map)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for map field 'attributes' (tag=3), expected 2 (length-delimited)", wt)
			}

			if m.Attributes == nil {
				m.Attributes = make(map[string]string)
			}
			// consume the map entry size
			// TODO - should we validate this?
			if _, err = dec.DecodeInt32(); err != nil {
				return err
			}
			// always 2 values
			var (
				entryKey   string
				entryValue string
			)
			for i := 0; i < 2; i++ {
				etag, ewt, err := dec.DecodeTag()
				if err != nil {
					return err
				}
				switch etag {
				case 1: // key
					if ewt != csproto.WireTypeLengthDelimited {
						return fmt.Errorf("incorrect wire type %v for map key for field 'attributes' (tag=3), expected 2 (length-delimited)", ewt)
					}
					if entryKey, err = dec.DecodeString(); err != nil {
						return err
					}
				case 2: // value
					if ewt != csproto.WireTypeLengthDelimited {
						return fmt.Errorf("incorrect wire type %v for map value for field 'attributes' (tag=3), expected 2 (length-delimited)", ewt)
					}
					if entryValue, err = dec.DecodeString(); err != nil {
						return err
					}
				default:
					return fmt.Errorf("invalid map entry field tag %d, expected 1 or 2", etag)
				}
			}
			m.Attributes[entryKey] = entryValue

		default:
			if skipped, err := dec.Skip(tag, wt); err != nil {
				return fmt.Errorf("invalid operation skipping tag %v: %w", tag, err)
			} else {
				m.unknownFields = append(m.unknownFields, skipped...)
			}
		}
	}
	return nil
}

//------------------------------------------------------------------------------
// Custom Protobuf size/marshal/unmarshal code for Maps

// Size calculates and returns the size, in bytes, required to hold the contents of m using the Protobuf
// binary encoding.
func (m *Maps) Size() int {
	// nil message is always 0 bytes
	if m == nil {
		return 0
	}
	// return cached size, if present
	if csz := int(atomic.LoadInt32(&m.sizeCache)); csz > 0 {
		return csz
	}
	// calculate and cache
	var sz, l int
	_ = l // avoid unused variable

	// Bools (message,repeated)
	for k, v := range m.Bools {
		// size of key (always has an internal tag of 1)
		l = len(k)
		keySize := 1 + csproto.SizeOfVarint(uint64(l)) + l
		// size of value (always has an internal tag of 2)
		_ = v
		valueSize := 1 + 1
		sz += csproto.SizeOfTagKey(1) + csproto.SizeOfVarint(uint64(keySize+valueSize)) + keySize + valueSize
	}

	// Strings (message,repeated)
	for k, v := range m.Strings {
		// size of key (always has an internal tag of 1)
		l = len(k)
		keySize := 1 + csproto.SizeOfVarint(uint64(l)) + l
		// size of value (always has an internal tag of 2)
		l = len(v)
		valueSize := 1 + csproto.SizeOfVarint(uint64(l)) + l
		sz += csproto.SizeOfTagKey(2) + csproto.SizeOfVarint(uint64(keySize+valueSize)) + keySize + valueSize
	}

	// Int32S (message,repeated)
	for k, v := range m.Int32S {
		// size of key (always has an internal tag of 1)
		keySize := 1 + csproto.SizeOfVarint(uint64(k))
		// size of value (always has an internal tag of 2)
		valueSize := 1 + csproto.SizeOfVarint(uint64(v))
		sz += csproto.SizeOfTagKey(3) + csproto.SizeOfVarint(uint64(keySize+valueSize)) + keySize + valueSize
	}

	// Int64S (message,repeated)
	for k, v := range m.Int64S {
		// size of key (always has an internal tag of 1)
		keySize := 1 + csproto.SizeOfVarint(uint64(k))
		// size of value (always has an internal tag of 2)
		valueSize := 1 + csproto.SizeOfVarint(uint64(v))
		sz += csproto.SizeOfTagKey(4) + csproto.SizeOfVarint(uint64(keySize+valueSize)) + keySize + valueSize
	}

	// Uint32S (message,repeated)
	for k, v := range m.Uint32S {
		// size of key (always has an internal tag of 1)
		keySize := 1 + csproto.SizeOfVarint(uint64(k))
		// size of value (always has an internal tag of 2)
		valueSize := 1 + csproto.SizeOfVarint(uint64(v))
		sz += csproto.SizeOfTagKey(5) + csproto.SizeOfVarint(uint64(keySize+valueSize)) + keySize + valueSize
	}

	// Uint64S (message,repeated)
	for k, v := range m.Uint64S {
		// size of key (always has an internal tag of 1)
		keySize := 1 + csproto.SizeOfVarint(uint64(k))
		// size of value (always has an internal tag of 2)
		valueSize := 1 + csproto.SizeOfVarint(uint64(v))
		sz += csproto.SizeOfTagKey(6) + csproto.SizeOfVarint(uint64(keySize+valueSize)) + keySize + valueSize
	}

	// Sint32S (message,repeated)
	for k, v := range m.Sint32S {
		// size of key (always has an internal tag of 1)
		keySize := 1 + csproto.SizeOfZigZag(uint64(k))
		// size of value (always has an internal tag of 2)
		valueSize := 1 + csproto.SizeOfZigZag(uint64(v))
		sz += csproto.SizeOfTagKey(7) + csproto.SizeOfVarint(uint64(keySize+valueSize)) + keySize + valueSize
	}

	// Sint64S (message,repeated)
	for k, v := range m.Sint64S {
		// size of key (always has an internal tag of 1)
		keySize := 1 + csproto.SizeOfZigZag(uint64(k))
		// size of value (always has an internal tag of 2)
		valueSize := 1 + csproto.SizeOfZigZag(uint64(v))
		sz += csproto.SizeOfTagKey(8) + csproto.SizeOfVarint(uint64(keySize+valueSize)) + keySize + valueSize
	}

	// Fixed32S (message,repeated)
	for k, v := range m.Fixed32S {
		// size of key (always has an internal tag of 1)
		_ = k
		keySize := 5
		// size of value (always has an internal tag of 2)
		_ = v
		sz += csproto.SizeOfTagKey(9) + csproto.SizeOfVarint(uint64(keySize+5)) + keySize + 5
	}

	// Fixed64S (message,repeated)
	for k, v := range m.Fixed64S {
		// size of key (always has an internal tag of 1)
		_ = k
		keySize := 9
		// size of value (always has an internal tag of 2)
		_ = v
		sz += csproto.SizeOfTagKey(10) + csproto.SizeOfVarint(uint64(keySize+9)) + keySize + 9
	}

	// Sfixed32S (message,repeated)
	for k, v := range m.Sfixed32S {
		// size of key (always has an internal tag of 1)
		_ = k
		keySize := 5
		// size of value (always has an internal tag of 2)
		_ = v
		sz += csproto.SizeOfTagKey(11) + csproto.SizeOfVarint(uint64(keySize+5)) + keySize + 5
	}

	// Sfixed64S (message,repeated)
	for k, v := range m.Sfixed64S {
		// size of key (always has an internal tag of 1)
		_ = k
		keySize := 9
		// size of value (always has an internal tag of 2)
		_ = v
		sz += csproto.SizeOfTagKey(12) + csproto.SizeOfVarint(uint64(keySize+9)) + keySize + 9
	}

	// Objects (message,repeated)
	for k, v := range m.Objects {
		// size of key (always has an internal tag of 1)
		l = len(k)
		keySize := 1 + csproto.SizeOfVarint(uint64(l)) + l
		// size of value (always has an internal tag of 2)
		if v != nil {
			l = csproto.Size(v)
			valueSize := 1 + csproto.SizeOfVarint(uint64(l)) + l
			sz += csproto.SizeOfTagKey(13) + csproto.SizeOfVarint(uint64(keySize+valueSize)) + keySize + valueSize
		}
	}

	// cache the size so it can be re-used in Marshal()/MarshalTo()
	atomic.StoreInt32(&m.sizeCache, int32(sz))
	return sz
}

// Marshal converts the contents of m to the Protobuf binary encoding and returns the result or an error.
func (m *Maps) Marshal() ([]byte, error) {
	siz := m.Size()
	buf := make([]byte, siz)
	err := m.MarshalTo(buf)
	return buf, err
}

// MarshalTo converts the contents of m to the Protobuf binary encoding and writes the result to dest.
func (m *Maps) MarshalTo(dest []byte) error {
	var (
		enc    = csproto.NewEncoder(dest)
		buf    []byte
		err    error
		extVal interface{}
	)
	// ensure no unused variables
	_ = enc
	_ = buf
	_ = err
	_ = extVal

	// Bools (1,map)
	for k, v := range m.Bools {
		_ = v
		itemSize := 1 + 1
		keySize := len(k)
		itemSize += 1 + csproto.SizeOfVarint(uint64(keySize)) + keySize
		enc.EncodeMapEntryHeader(1, itemSize)
		enc.EncodeString(1, k)
		enc.EncodeBool(2, v)
	}

	// Strings (2,map)
	for k, v := range m.Strings {
		valueSize := len(v)
		itemSize := 1 + csproto.SizeOfVarint(uint64(valueSize)) + valueSize
		keySize := len(k)
		itemSize += 1 + csproto.SizeOfVarint(uint64(keySize)) + keySize
		enc.EncodeMapEntryHeader(2, itemSize)
		enc.EncodeString(1, k)
		enc.EncodeString(2, v)
	}

	// Int32S (3,map)
	for k, v := range m.Int32S {
		itemSize := 1 + csproto.SizeOfVarint(uint64(v))
		itemSize += 1 + csproto.SizeOfVarint(uint64(k))
		enc.EncodeMapEntryHeader(3, itemSize)
		enc.EncodeUInt64(1, uint64(k))
		enc.EncodeUInt64(2, uint64(v))
	}

	// Int64S (4,map)
	for k, v := range m.Int64S {
		itemSize := 1 + csproto.SizeOfVarint(uint64(v))
		itemSize += 1 + csproto.SizeOfVarint(uint64(k))
		enc.EncodeMapEntryHeader(4, itemSize)
		enc.EncodeUInt64(1, uint64(k))
		enc.EncodeUInt64(2, uint64(v))
	}

	// Uint32S (5,map)
	for k, v := range m.Uint32S {
		itemSize := 1 + csproto.SizeOfVarint(uint64(v))
		itemSize += 1 + csproto.SizeOfVarint(uint64(k))
		enc.EncodeMapEntryHeader(5, itemSize)
		enc.EncodeUInt64(1, uint64(k))
		enc.EncodeUInt64(2, uint64(v))
	}

	// Uint64S (6,map)
	for k, v := range m.Uint64S {
		itemSize := 1 + csproto.SizeOfVarint(uint64(v))
		itemSize += 1 + csproto.SizeOfVarint(uint64(k))
		enc.EncodeMapEntryHeader(6, itemSize)
		enc.EncodeUInt64(1, uint64(k))
		enc.EncodeUInt64(2, uint64(v))
	}

	// Sint32S (7,map)
	for k, v := range m.Sint32S {
		itemSize := 1 + csproto.SizeOfZigZag(uint64(v))
		itemSize += 1 + csproto.SizeOfZigZag(uint64(k))
		enc.EncodeMapEntryHeader(7, itemSize)
		enc.EncodeSInt32(1, k)
		enc.EncodeSInt32(2, v)
	}

	// Sint64S (8,map)
	for k, v := range m.Sint64S {
		itemSize := 1 + csproto.SizeOfZigZag(uint64(v))
		itemSize += 1 + csproto.SizeOfZigZag(uint64(k))
		enc.EncodeMapEntryHeader(8, itemSize)
		enc.EncodeSInt64(1, k)
		enc.EncodeSInt64(2, v)
	}

	// Fixed32S (9,map)
	for k, v := range m.Fixed32S {
		itemSize := 5
		itemSize += 5
		enc.EncodeMapEntryHeader(9, itemSize)
		enc.EncodeFixed32(1, uint32(k))
		enc.EncodeFixed32(2, uint32(v))
	}

	// Fixed64S (10,map)
	for k, v := range m.Fixed64S {
		itemSize := 9
		itemSize += 9
		enc.EncodeMapEntryHeader(10, itemSize)
		enc.EncodeFixed64(1, uint64(k))
		enc.EncodeFixed64(2, uint64(v))
	}

	// Sfixed32S (11,map)
	for k, v := range m.Sfixed32S {
		itemSize := 5
		itemSize += 5
		enc.EncodeMapEntryHeader(11, itemSize)
		enc.EncodeFixed32(1, uint32(k))
		enc.EncodeFixed32(2, uint32(v))
	}

	// Sfixed64S (12,map)
	for k, v := range m.Sfixed64S {
		itemSize := 9
		itemSize += 9
		enc.EncodeMapEntryHeader(12, itemSize)
		enc.EncodeFixed64(1, uint64(k))
		enc.EncodeFixed64(2, uint64(v))
	}

	// Objects (13,map)
	for k, v := range m.Objects {
		if v == nil {
			continue
		}
		valueSize := csproto.Size(v)
		itemSize := 1 + csproto.SizeOfVarint(uint64(valueSize)) + valueSize
		keySize := len(k)
		itemSize += 1 + csproto.SizeOfVarint(uint64(keySize)) + keySize
		enc.EncodeMapEntryHeader(13, itemSize)
		enc.EncodeString(1, k)
		enc.EncodeNested(2, v)
	}

	return nil
}

// Unmarshal decodes a binary encoded Protobuf message from p and populates m with the result.
func (m *Maps) Unmarshal(p []byte) error {
	m.Reset()
	if len(p) == 0 {
		return nil
	}
	dec := csproto.NewDecoder(p)
	for dec.More() {
		tag, wt, err := dec.DecodeTag()
		if err != nil {
			return err
		}
		switch tag {
		case 1: // Bools (map)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for map field 'bools' (tag=1), expected 2 (length-delimited)", wt)
			}

			if m.Bools == nil {
				m.Bools = make(map[string]bool)
			}
			// consume the map entry size
			// TODO - should we validate this?
			if _, err = dec.DecodeInt32(); err != nil {
				return err
			}
			// always 2 values
			var (
				entryKey   string
				entryValue bool
			)
			for i := 0; i < 2; i++ {
				etag, ewt, err := dec.DecodeTag()
				if err != nil {
					return err
				}
				switch etag {
				case 1: // key
					if ewt != csproto.WireTypeLengthDelimited {
						return fmt.Errorf("incorrect wire type %v for map key for field 'bools' (tag=1), expected 2 (length-delimited)", ewt)
					}
					if entryKey, err = dec.DecodeString(); err != nil {
						return err
					}
				case 2: // value
					if ewt != csproto.WireTypeVarint {
						return fmt.Errorf("incorrect wire type %v for map value for field 'bools' (tag=1), expected 0 (varint)", ewt)
					}
					if entryValue, err = dec.DecodeBool(); err != nil {
						return err
					}
				default:
					return fmt.Errorf("invalid map entry field tag %d, expected 1 or 2", etag)
				}
			}
			m.Bools[entryKey] = entryValue
		case 2: // Strings (map)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for map field 'strings' (tag=2), expected 2 (length-delimited)", wt)
			}

			if m.Strings == nil {
				m.Strings = make(map[string]string)
			}
			// consume the map entry size
			// TODO - should we validate this?
			if _, err = dec.DecodeInt32(); err != nil {
				return err
			}
			// always 2 values
			var (
				entryKey   string
				entryValue string
			)
			for i := 0; i < 2; i++ {
				etag, ewt, err := dec.DecodeTag()
				if err != nil {
					return err
				}
				switch etag {
				case 1: // key
					if ewt != csproto.WireTypeLengthDelimited {
						return fmt.Errorf("incorrect wire type %v for map key for field 'strings' (tag=2), expected 2 (length-delimited)", ewt)
					}
					if entryKey, err = dec.DecodeString(); err != nil {
						return err
					}
				case 2: // value
					if ewt != csproto.WireTypeLengthDelimited {
						return fmt.Errorf("incorrect wire type %v for map value for field 'strings' (tag=2), expected 2 (length-delimited)", ewt)
					}
					if entryValue, err = dec.DecodeString(); err != nil {
						return err
					}
				default:
					return fmt.Errorf("invalid map entry field tag %d, expected 1 or 2", etag)
				}
			}
			m.Strings[entryKey] = entryValue
		case 3: // Int32S (map)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for map field 'int32s' (tag=3), expected 2 (length-delimited)", wt)
			}

			if m.Int32S == nil {
				m.Int32S = make(map[int32]int32)
			}
			// consume the map entry size
			// TODO - should we validate this?
			if _, err = dec.DecodeInt32(); err != nil {
				return err
			}
			// always 2 values
			var (
				entryKey   int32
				entryValue int32
			)
			for i := 0; i < 2; i++ {
				etag, ewt, err := dec.DecodeTag()
				if err != nil {
					return err
				}
				switch etag {
				case 1: // key
					if ewt != csproto.WireTypeVarint {
						return fmt.Errorf("incorrect wire type %v for map key for field 'int32s' (tag=3), expected 0 (varint)", ewt)
					}
					if entryKey, err = dec.DecodeInt32(); err != nil {
						return err
					}
				case 2: // value
					if ewt != csproto.WireTypeVarint {
						return fmt.Errorf("incorrect wire type %v for map value for field 'int32s' (tag=3), expected 0 (varint)", ewt)
					}
					if entryValue, err = dec.DecodeInt32(); err != nil {
						return err
					}
				default:
					return fmt.Errorf("invalid map entry field tag %d, expected 1 or 2", etag)
				}
			}
			m.Int32S[entryKey] = entryValue
		case 4: // Int64S (map)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for map field 'int64s' (tag=4), expected 2 (length-delimited)", wt)
			}

			if m.Int64S == nil {
				m.Int64S = make(map[int64]int64)
			}
			// consume the map entry size
			// TODO - should we validate this?
			if _, err = dec.DecodeInt32(); err != nil {
				return err
			}
			// always 2 values
			var (
				entryKey   int64
				entryValue int64
			)
			for i := 0; i < 2; i++ {
				etag, ewt, err := dec.DecodeTag()
				if err != nil {
					return err
				}
				switch etag {
				case 1: // key
					if ewt != csproto.WireTypeVarint {
						return fmt.Errorf("incorrect wire type %v for map key for field 'int64s' (tag=4), expected 0 (varint)", ewt)
					}
					if entryKey, err = dec.DecodeInt64(); err != nil {
						return err
					}
				case 2: // value
					if ewt != csproto.WireTypeVarint {
						return fmt.Errorf("incorrect wire type %v for map value for field 'int64s' (tag=4), expected 0 (varint)", ewt)
					}
					if entryValue, err = dec.DecodeInt64(); err != nil {
						return err
					}
				default:
					return fmt.Errorf("invalid map entry field tag %d, expected 1 or 2", etag)
				}
			}
			m.Int64S[entryKey] = entryValue
		case 5: // Uint32S (map)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for map field 'uint32s' (tag=5), expected 2 (length-delimited)", wt)
			}

			if m.Uint32S == nil {
				m.Uint32S = make(map[uint32]uint32)
			}
			// consume the map entry size
			// TODO - should we validate this?
			if _, err = dec.DecodeInt32(); err != nil {
				return err
			}
			// always 2 values
			var (
				entryKey   uint32
				entryValue uint32
			)
			for i := 0; i < 2; i++ {
				etag, ewt, err := dec.DecodeTag()
				if err != nil {
					return err
				}
				switch etag {
				case 1: // key
					if ewt != csproto.WireTypeVarint {
						return fmt.Errorf("incorrect wire type %v for map key for field 'uint32s' (tag=5), expected 0 (varint)", ewt)
					}
					if entryKey, err = dec.DecodeUInt32(); err != nil {
						return err
					}
				case 2: // value
					if ewt != csproto.WireTypeVarint {
						return fmt.Errorf("incorrect wire type %v for map value for field 'uint32s' (tag=5), expected 0 (varint)", ewt)
					}
					if entryValue, err = dec.DecodeUInt32(); err != nil {
						return err
					}
				default:
					return fmt.Errorf("invalid map entry field tag %d, expected 1 or 2", etag)
				}
			}
			m.Uint32S[entryKey] = entryValue
		case 6: // Uint64S (map)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for map field 'uint64s' (tag=6), expected 2 (length-delimited)", wt)
			}

			if m.Uint64S == nil {
				m.Uint64S = make(map[uint64]uint64)
			}
			// consume the map entry size
			// TODO - should we validate this?
			if _, err = dec.DecodeInt32(); err != nil {
				return err
			}
			// always 2 values
			var (
				entryKey   uint64
				entryValue uint64
			)
			for i := 0; i < 2; i++ {
				etag, ewt, err := dec.DecodeTag()
				if err != nil {
					return err
				}
				switch etag {
				case 1: // key
					if ewt != csproto.WireTypeVarint {
						return fmt.Errorf("incorrect wire type %v for map key for field 'uint64s' (tag=6), expected 0 (varint)", ewt)
					}
					if entryKey, err = dec.DecodeUInt64(); err != nil {
						return err
					}
				case 2: // value
					if ewt != csproto.WireTypeVarint {
						return fmt.Errorf("incorrect wire type %v for map value for field 'uint64s' (tag=6), expected 0 (varint)", ewt)
					}
					if entryValue, err = dec.DecodeUInt64(); err != nil {
						return err
					}
				default:
					return fmt.Errorf("invalid map entry field tag %d, expected 1 or 2", etag)
				}
			}
			m.Uint64S[entryKey] = entryValue
		case 7: // Sint32S (map)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for map field 'sint32s' (tag=7), expected 2 (length-delimited)", wt)
			}

			if m.Sint32S == nil {
				m.Sint32S = make(map[int32]int32)
			}
			// consume the map entry size
			// TODO - should we validate this?
			if _, err = dec.DecodeInt32(); err != nil {
				return err
			}
			// always 2 values
			var (
				entryKey   int32
				entryValue int32
			)
			for i := 0; i < 2; i++ {
				etag, ewt, err := dec.DecodeTag()
				if err != nil {
					return err
				}
				switch etag {
				case 1: // key
					if ewt != csproto.WireTypeVarint {
						return fmt.Errorf("incorrect wire type %v for map key for field 'sint32s' (tag=7), expected 0 (varint)", ewt)
					}
					if entryKey, err = dec.DecodeSInt32(); err != nil {
						return err
					}
				case 2: // value
					if ewt != csproto.WireTypeVarint {
						return fmt.Errorf("incorrect wire type %v for map value for field 'sint32s' (tag=7), expected 0 (varint)", ewt)
					}
					if entryValue, err = dec.DecodeSInt32(); err != nil {
						return err
					}
				default:
					return fmt.Errorf("invalid map entry field tag %d, expected 1 or 2", etag)
				}
			}
			m.Sint32S[entryKey] = entryValue
		case 8: // Sint64S (map)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for map field 'sint64s' (tag=8), expected 2 (length-delimited)", wt)
			}

			if m.Sint64S == nil {
				m.Sint64S = make(map[int64]int64)
			}
			// consume the map entry size
			// TODO - should we validate this?
			if _, err = dec.DecodeInt32(); err != nil {
				return err
			}
			// always 2 values
			var (
				entryKey   int64
				entryValue int64
			)
			for i := 0; i < 2; i++ {
				etag, ewt, err := dec.DecodeTag()
				if err != nil {
					return err
				}
				switch etag {
				case 1: // key
					if ewt != csproto.WireTypeVarint {
						return fmt.Errorf("incorrect wire type %v for map key for field 'sint64s' (tag=8), expected 0 (varint)", ewt)
					}
					if entryKey, err = dec.DecodeSInt64(); err != nil {
						return err
					}
				case 2: // value
					if ewt != csproto.WireTypeVarint {
						return fmt.Errorf("incorrect wire type %v for map value for field 'sint64s' (tag=8), expected 0 (varint)", ewt)
					}
					if entryValue, err = dec.DecodeSInt64(); err != nil {
						return err
					}
				default:
					return fmt.Errorf("invalid map entry field tag %d, expected 1 or 2", etag)
				}
			}
			m.Sint64S[entryKey] = entryValue
		case 9: // Fixed32S (map)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for map field 'fixed32s' (tag=9), expected 2 (length-delimited)", wt)
			}

			if m.Fixed32S == nil {
				m.Fixed32S = make(map[uint32]uint32)
			}
			// consume the map entry size
			// TODO - should we validate this?
			if _, err = dec.DecodeInt32(); err != nil {
				return err
			}
			// always 2 values
			var (
				entryKey   uint32
				entryValue uint32
			)
			for i := 0; i < 2; i++ {
				etag, ewt, err := dec.DecodeTag()
				if err != nil {
					return err
				}
				switch etag {
				case 1: // key
					if ewt != csproto.WireTypeFixed32 {
						return fmt.Errorf("incorrect wire type %v for map key for field 'fixed32s' (tag=9), expected 5 (fixed32)", ewt)
					}
					if entryKey, err = dec.DecodeFixed32(); err != nil {
						return err
					}
				case 2: // value
					if ewt != csproto.WireTypeFixed32 {
						return fmt.Errorf("incorrect wire type %v for map value for field 'fixed32s' (tag=9), expected 5 (fixed32)", ewt)
					}
					if entryValue, err = dec.DecodeFixed32(); err != nil {
						return err
					}
				default:
					return fmt.Errorf("invalid map entry field tag %d, expected 1 or 2", etag)
				}
			}
			m.Fixed32S[entryKey] = entryValue
		case 10: // Fixed64S (map)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for map field 'fixed64s' (tag=10), expected 2 (length-delimited)", wt)
			}

			if m.Fixed64S == nil {
				m.Fixed64S = make(map[uint64]uint64)
			}
			// consume the map entry size
			// TODO - should we validate this?
			if _, err = dec.DecodeInt32(); err != nil {
				return err
			}
			// always 2 values
			var (
				entryKey   uint64
				entryValue uint64
			)
			for i := 0; i < 2; i++ {
				etag, ewt, err := dec.DecodeTag()
				if err != nil {
					return err
				}
				switch etag {
				case 1: // key
					if ewt != csproto.WireTypeFixed64 {
						return fmt.Errorf("incorrect wire type %v for map key for field 'fixed64s' (tag=10), expected 1 (fixed64)", ewt)
					}
					if entryKey, err = dec.DecodeFixed64(); err != nil {
						return err
					}
				case 2: // value
					if ewt != csproto.WireTypeFixed64 {
						return fmt.Errorf("incorrect wire type %v for map value for field 'fixed64s' (tag=10), expected 1 (fixed64)", ewt)
					}
					if entryValue, err = dec.DecodeFixed64(); err != nil {
						return err
					}
				default:
					return fmt.Errorf("invalid map entry field tag %d, expected 1 or 2", etag)
				}
			}
			m.Fixed64S[entryKey] = entryValue
		case 11: // Sfixed32S (map)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for map field 'sfixed32s' (tag=11), expected 2 (length-delimited)", wt)
			}

			if m.Sfixed32S == nil {
				m.Sfixed32S = make(map[int32]int32)
			}
			// consume the map entry size
			// TODO - should we validate this?
			if _, err = dec.DecodeInt32(); err != nil {
				return err
			}
			// always 2 values
			var (
				entryKey   int32
				entryValue int32
			)
			for i := 0; i < 2; i++ {
				etag, ewt, err := dec.DecodeTag()
				if err != nil {
					return err
				}
				switch etag {
				case 1: // key
					if ewt != csproto.WireTypeFixed32 {
						return fmt.Errorf("incorrect wire type %v for map key for field 'sfixed32s' (tag=11), expected 5 (fixed32)", ewt)
					}
					if sv, err := dec.DecodeFixed32(); err != nil {
						return err
					} else {
						entryKey = int32(sv)
					}
				case 2: // value
					if ewt != csproto.WireTypeFixed32 {
						return fmt.Errorf("incorrect wire type %v for map value for field 'sfixed32s' (tag=11), expected 5 (fixed32)", ewt)
					}
					if sv, err := dec.DecodeFixed32(); err != nil {
						return err
					} else {
						entryValue = int32(sv)
					}
				default:
					return fmt.Errorf("invalid map entry field tag %d, expected 1 or 2", etag)
				}
			}
			m.Sfixed32S[entryKey] = entryValue
		case 12: // Sfixed64S (map)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for map field 'sfixed64s' (tag=12), expected 2 (length-delimited)", wt)
			}

			if m.Sfixed64S == nil {
				m.Sfixed64S = make(map[int64]int64)
			}
			// consume the map entry size
			// TODO - should we validate this?
			if _, err = dec.DecodeInt32(); err != nil {
				return err
			}
			// always 2 values
			var (
				entryKey   int64
				entryValue int64
			)
			for i := 0; i < 2; i++ {
				etag, ewt, err := dec.DecodeTag()
				if err != nil {
					return err
				}
				switch etag {
				case 1: // key
					if ewt != csproto.WireTypeFixed64 {
						return fmt.Errorf("incorrect wire type %v for map key for field 'sfixed64s' (tag=12), expected 1 (fixed64)", ewt)
					}
					if sv, err := dec.DecodeFixed64(); err != nil {
						return err
					} else {
						entryKey = int64(sv)
					}
				case 2: // value
					if ewt != csproto.WireTypeFixed64 {
						return fmt.Errorf("incorrect wire type %v for map value for field 'sfixed64s' (tag=12), expected 1 (fixed64)", ewt)
					}
					if sv, err := dec.DecodeFixed64(); err != nil {
						return err
					} else {
						entryValue = int64(sv)
					}
				default:
					return fmt.Errorf("invalid map entry field tag %d, expected 1 or 2", etag)
				}
			}
			m.Sfixed64S[entryKey] = entryValue
		case 13: // Objects (map)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for map field 'objects' (tag=13), expected 2 (length-delimited)", wt)
			}

			if m.Objects == nil {
				m.Objects = make(map[string]*MapObject)
			}
			// consume the map entry size
			// TODO - should we validate this?
			if _, err = dec.DecodeInt32(); err != nil {
				return err
			}
			// always 2 values
			var (
				entryKey   string
				entryValue *MapObject
			)
			for i := 0; i < 2; i++ {
				etag, ewt, err := dec.DecodeTag()
				if err != nil {
					return err
				}
				switch etag {
				case 1: // key
					if ewt != csproto.WireTypeLengthDelimited {
						return fmt.Errorf("incorrect wire type %v for map key for field 'objects' (tag=13), expected 2 (length-delimited)", ewt)
					}
					if entryKey, err = dec.DecodeString(); err != nil {
						return err
					}
				case 2: // value
					if ewt != csproto.WireTypeLengthDelimited {
						return fmt.Errorf("incorrect wire type %v for map value for field 'objects' (tag=13), expected 2 (length-delimited)", ewt)
					}
					var v MapObject
					if err = dec.DecodeNested(&v); err != nil {
						return err
					} else {
						entryValue = &v
					}
				default:
					return fmt.Errorf("invalid map entry field tag %d, expected 1 or 2", etag)
				}
			}
			m.Objects[entryKey] = entryValue

		default:
			if skipped, err := dec.Skip(tag, wt); err != nil {
				return fmt.Errorf("invalid operation skipping tag %v: %w", tag, err)
			} else {
				m.unknownFields = append(m.unknownFields, skipped...)
			}
		}
	}
	return nil
}

//------------------------------------------------------------------------------
// Custom Protobuf size/marshal/unmarshal code for TestEvent_NestedMsg

// Size calculates and returns the size, in bytes, required to hold the contents of m using the Protobuf
// binary encoding.
func (m *TestEvent_NestedMsg) Size() int {
	// nil message is always 0 bytes
	if m == nil {
		return 0
	}
	// return cached size, if present
	if csz := int(atomic.LoadInt32(&m.sizeCache)); csz > 0 {
		return csz
	}
	// calculate and cache
	var sz, l int
	_ = l // avoid unused variable

	// Details (string,optional)
	if l = len(m.Details); l > 0 {
		sz += csproto.SizeOfTagKey(1) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// cache the size so it can be re-used in Marshal()/MarshalTo()
	atomic.StoreInt32(&m.sizeCache, int32(sz))
	return sz
}

// Marshal converts the contents of m to the Protobuf binary encoding and returns the result or an error.
func (m *TestEvent_NestedMsg) Marshal() ([]byte, error) {
	siz := m.Size()
	buf := make([]byte, siz)
	err := m.MarshalTo(buf)
	return buf, err
}

// MarshalTo converts the contents of m to the Protobuf binary encoding and writes the result to dest.
func (m *TestEvent_NestedMsg) MarshalTo(dest []byte) error {
	var (
		enc    = csproto.NewEncoder(dest)
		buf    []byte
		err    error
		extVal interface{}
	)
	// ensure no unused variables
	_ = enc
	_ = buf
	_ = err
	_ = extVal

	// Details (1,string,optional)
	if len(m.Details) > 0 {
		enc.EncodeString(1, m.Details)
	}
	return nil
}

// Unmarshal decodes a binary encoded Protobuf message from p and populates m with the result.
func (m *TestEvent_NestedMsg) Unmarshal(p []byte) error {
	m.Reset()
	if len(p) == 0 {
		return nil
	}
	dec := csproto.NewDecoder(p)
	for dec.More() {
		tag, wt, err := dec.DecodeTag()
		if err != nil {
			return err
		}
		switch tag {
		case 1: // Details (string,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'details' (tag=1), expected 2 (length-delimited)", wt)
			}
			if s, err := dec.DecodeString(); err != nil {
				return fmt.Errorf("unable to decode string value for field 'details' (tag=1): %w", err)
			} else {
				m.Details = s
			}

		default:
			if skipped, err := dec.Skip(tag, wt); err != nil {
				return fmt.Errorf("invalid operation skipping tag %v: %w", tag, err)
			} else {
				m.unknownFields = append(m.unknownFields, skipped...)
			}
		}
	}
	return nil
}
