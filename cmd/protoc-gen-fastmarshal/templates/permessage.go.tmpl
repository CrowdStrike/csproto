{{define "PerMessage"}}
{{- $protoSyntax := (.Message.Desc.Syntax | string) -}}
{{- $protoAPIVersion := .APIVersion -}}
{{- $useUnsafeDecoder := .EnableUnsafeDecode -}}
// GENERATED CODE - DO NOT EDIT
// This file was generated by protoc-gen-fastmarshal

package {{ .ProtoDesc.GoPackageName }}

import (
    "fmt"{{if and (eq $protoSyntax "proto2") (hasRequiredFields nil)}}
    "strings"{{end}}
    "sync/atomic"
    "github.com/CrowdStrike/csproto"
    {{range $path, $alias := (.Message | getAdditionalImports)}}{{ (printf "%s %s" $alias $path) | trimspace}}
    {{end}}
)

//------------------------------------------------------------------------------
// Custom Protobuf size/marshal/unmarshal code for {{ .Message.GoIdent.GoName }}

// Size calculates and returns the size, in bytes, required to hold the contents of m using the Protobuf
// binary encoding.
func (m *{{ .Message.GoIdent.GoName }}) Size() int {
    // nil message is always 0 bytes
    if m == nil {
        return 0
    }
    // return cached size, if present
{{ if eq $protoAPIVersion "v1" -}}
    if csz := int(atomic.LoadInt32(&m.XXX_sizecache)); csz > 0 {
{{- else -}}
    if csz := int(atomic.LoadInt32(&m.sizeCache)); csz > 0 {
{{- end }}
        return csz
    }
    // calculate and cache
    var sz, l int
    _ = l // avoid unused variable
{{ range .Message.Fields }}
{{- if eq .Desc.ContainingOneof nil }}
    // {{ .GoName }} ({{.Desc.Kind}},{{.Desc.Cardinality}}{{if .Desc.IsPacked }},packed{{ end }})
    {{ template "SizeOfField" . }}
{{- end -}}
{{ end }}
{{ range .Message.Oneofs }}
    {{- template "SizeOfOneOf" . }}
{{ end }}
{{- if eq $protoSyntax "proto2" -}}
{{ range getExtensions .Message }}
    {{- template "SizeOfExtension" . }}
{{ end }}
{{- end -}}
    // cache the size so it can be re-used in Marshal()/MarshalTo()
{{ if eq $protoAPIVersion "v1" -}}
    atomic.StoreInt32(&m.XXX_sizecache, int32(sz))
{{- else -}}
    atomic.StoreInt32(&m.sizeCache, int32(sz))
{{- end }}
    return sz
}

// Marshal converts the contents of m to the Protobuf binary encoding and returns the result or an error.
func (m *{{ .Message.GoIdent.GoName }}) Marshal() ([]byte, error) {
    siz := m.Size()
    if siz == 0 {
        return []byte{}, nil
    }
    buf := make([]byte, siz)
    err := m.MarshalTo(buf)
    return buf, err
}

// MarshalTo converts the contents of m to the Protobuf binary encoding and writes the result to dest.
func (m *{{ .Message.GoIdent.GoName }}) MarshalTo(dest []byte) error {
    // nil message == no-op
    if m == nil {
        return nil
    }
	var (
    	enc = csproto.NewEncoder(dest)
		buf []byte
		err error
        extVal interface{}
	)
    // ensure no unused variables
    _ = enc
    _ = buf
    _ = err
    _ = extVal
{{ range .Message.Fields }}
{{- if eq .Desc.ContainingOneof nil }}
    // {{ .GoName }} ({{.Desc.Number}},{{if .Desc.IsMap}}map{{else}}{{.Desc.Kind}},{{.Desc.Cardinality}}{{if .Desc.IsPacked }},packed{{ end }}{{end}})
    {{ template "MarshalField" . }}
{{- end -}}
{{ end }}
{{ range .Message.Oneofs -}}
    // {{.GoName}} (oneof)
    {{ template "MarshalOneOf" . -}}
{{ end }}
{{- if eq $protoSyntax "proto2" -}}
{{ range getExtensions .Message }}
    {{ template "MarshalExtension" . }}
{{ end }}
{{- end -}}
    return nil
}

// Unmarshal decodes a binary encoded Protobuf message from p and populates m with the result.
func (m *{{ .Message.GoIdent.GoName}}) Unmarshal(p []byte) error {
    m.Reset()
    if len(p) == 0 {
        return nil
    }
    dec := csproto.NewDecoder(p)
    {{if $useUnsafeDecoder -}}
    // enable faster, but unsafe, string decoding
    dec.SetMode(csproto.DecoderModeFast)
    {{end -}}
    for dec.More() {
		tag, wt, err := dec.DecodeTag()
		if err != nil {
			return err
		}
		switch tag {
        {{- range .Message.Fields -}}
        {{ if eq .Desc.ContainingOneof nil }}case {{ .Desc.Number }}: // {{ .GoName }} ({{if .Desc.IsMap}}map{{else}}{{.Desc.Kind}},{{.Desc.Cardinality}}{{if .Desc.IsPacked }},packed{{ end }}{{end}})
        {{ template "UnmarshalField" . }}{{ end }}
        {{ end }}
        {{ range .Message.Oneofs -}}
        {{ template "UnmarshalOneOf" . -}}
        {{ end }}
        {{- if eq $protoSyntax "proto2" -}}
        {{ range getExtensions . }}
        {{ template "UnmarshalExtension" . }}
        {{ end }}
        {{- end -}}
        default:
            if skipped, err := dec.Skip(tag, wt); err != nil {
                return fmt.Errorf("invalid operation skipping tag %v: %w", tag, err)
            } else {
            {{- if eq $protoAPIVersion "v1" -}}
                m.XXX_unrecognized = append(m.XXX_unrecognized, skipped...)
            {{- else if eq $protoAPIVersion "v2" -}}
                m.unknownFields = append(m.unknownFields, skipped...)
            {{- else -}}
            panic(fmt.Errorf("unknown/unsupported protobuf runtime '{{ $protoAPIVersion }}'"))
            {{- end -}}
            }
        }
    }{{if hasRequiredFields .Message }}
    // verify required fields are assigned
    if err := m.csprotoCheckRequiredFields(); err != nil {
        return err
    }
    {{end}}
    return nil
}
{{if hasRequiredFields .Message}}

// csprotoCheckRequiredFields is called by Unmarshal() to ensure that all required fields have been
// populated.
func (m *{{.Message.GoIdent.GoName}}) csprotoCheckRequiredFields() error {
    var missingFields []string
{{ range .Message.Fields }}
{{ if and (eq (.Desc.Cardinality | string) "required") (eq (.Desc.Syntax | string) "proto2") -}}
    if m.{{.GoName | getSafeFieldName}} == nil {
        missingFields = append(missingFields, "{{.GoName | getSafeFieldName}}")
    }
{{- end -}}
{{ end }}
    if len(missingFields) > 0 {
        var sb strings.Builder
        sb.WriteString("cannot unmarshal, one or more required fields missing: ")
        for i, s := range missingFields {
            if i > 0 {
                sb.WriteRune(',')
            }
            sb.WriteString(s)
        }
        return fmt.Errorf(sb.String())
    }
    return nil
}
{{ end }}
{{end}}