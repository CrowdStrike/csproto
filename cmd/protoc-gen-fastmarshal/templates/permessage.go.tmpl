{{define "PerMessage"}}
{{- $protoSyntax := (.Message.Desc.Syntax | string) -}}
{{- $protoAPIVersion := .APIVersion -}}
// GENERATED CODE - DO NOT EDIT
// This file was generated by protoc-gen-fastmarshal

package {{ .ProtoDesc.GoPackageName }}

import (
    "fmt"
    "github.com/CrowdStrike/csproto"
    {{range (.Message | getAdditionalImports)}}{{.}}
    {{end}}
)

//------------------------------------------------------------------------------
// Custom Protobuf size/marshal/unmarshal code for {{ .Message.GoIdent.GoName }}

// Size calculates and returns the size, in bytes, required to hold the contents of m using the Protobuf
// binary encoding.
func (m *{{ .Message.GoIdent.GoName }}) Size() int {
    if m == nil {
        return 0
    }
    var sz, l int
    _ = l // avoid unused variable
{{ range .Message.Fields }}
{{- if eq .Desc.ContainingOneof nil }}
    // {{ .GoName }} ({{.Desc.Kind}},{{.Desc.Cardinality}}{{if .Desc.IsPacked }},packed{{ end }})
    {{ template "SizeOfField" . }}
{{- end -}}
{{ end }}
{{ range .Message.Oneofs }}
    {{- template "SizeOfOneOf" . }}
{{ end }}
{{- if eq $protoSyntax "proto2" -}}
{{ range getExtensions .Message }}
    {{- template "SizeOfExtension" . }}
{{ end }}
{{- end -}}
    return sz
}

// Marshal converts the contents of m to the Protobuf binary encoding and returns the result or an error.
func (m *{{ .Message.GoIdent.GoName }}) Marshal() ([]byte, error) {
    siz := m.Size()
    buf := make([]byte, siz)
    err := m.MarshalTo(buf)
    return buf, err
}

// MarshalTo converts the contents of m to the Protobuf binary encoding and writes the result to dest.
func (m *{{ .Message.GoIdent.GoName }}) MarshalTo(dest []byte) error {
	var (
    	enc = csproto.NewEncoder(dest)
		buf []byte
		err error
	)
	_, _ = buf, err // ensure no unused variables
{{ range .Message.Fields }}
{{- if eq .Desc.ContainingOneof nil }}
    // {{ .GoName }} ({{.Desc.Number}},{{.Desc.Kind}},{{.Desc.Cardinality}}{{if .Desc.IsPacked }},packed{{ end }})
    {{ template "MarshalField" . }}
{{- end -}}
{{ end }}
{{ range .Message.Oneofs -}}
    // {{.GoName}} (oneof)
    {{ template "MarshalOneOf" . -}}
{{ end }}
{{- if eq $protoSyntax "proto2" -}}
{{ range getExtensions .Message }}
    {{ template "MarshalExtension" . }}
{{ end }}
{{- end -}}
    return nil
}

// Unmarshal decodes a binary encoded Protobuf message from p and populates m with the result.
func (m *{{ .Message.GoIdent.GoName}}) Unmarshal(p []byte) error {
    if len(p) == 0 {
        return fmt.Errorf("cannot unmarshal from an empty buffer")
    }
    // clear any existing data
    m.Reset()
    dec := csproto.NewDecoder(p)
    for dec.More() {
		tag, wt, err := dec.DecodeTag()
		if err != nil {
			return err
		}
		switch tag {
        {{- range .Message.Fields -}}
        {{ if eq .Desc.ContainingOneof nil }}case {{ .Desc.Number }}: // {{ .GoName }} ({{.Desc.Kind}},{{.Desc.Cardinality}}{{if .Desc.IsPacked }},packed{{ end }})
        {{ template "UnmarshalField" . }}{{ end }}
        {{ end }}
        {{ range .Message.Oneofs -}}
        {{ template "UnmarshalOneOf" . -}}
        {{ end }}
        {{- if eq $protoSyntax "proto2" -}}
        {{ range getExtensions . }}
        {{ template "UnmarshalExtension" . }}
        {{ end }}
        {{- end -}}
        default:
            if skipped, err := dec.Skip(tag, wt); err != nil {
                return fmt.Errorf("invalid operation skipping tag %v: %w", tag, err)
            } else {
            {{- if eq $protoAPIVersion "v1" -}}
                m.XXX_unrecognized = append(m.XXX_unrecognized, skipped...)
            {{- else if eq $protoAPIVersion "v2" -}}
                m.unknownFields = append(m.unknownFields, skipped...)
            {{- else -}}
            panic(fmt.Errorf("unknown/unsupported protobuf runtime '{{ $protoAPIVersion }}'"))
            {{- end -}}
            }
        }
    }
    return nil
}
{{end}}